<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Spring Cloud Gateway之 Predicate、GatewayFilter</title>
      <link href="/2020/01/31/spring-cloud/Spring%20Cloud%20Gateway%E4%B9%8B%20Predicate%E3%80%81GatewayFilter/"/>
      <url>/2020/01/31/spring-cloud/Spring%20Cloud%20Gateway%E4%B9%8B%20Predicate%E3%80%81GatewayFilter/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Cloud-Gateway之-Predicate、GatewayFilter"><a href="#Spring-Cloud-Gateway之-Predicate、GatewayFilter" class="headerlink" title="Spring Cloud Gateway之 Predicate、GatewayFilter"></a>Spring Cloud Gateway之 Predicate、GatewayFilter</h1><h2 id="Route-Predicate-Factories"><a href="#Route-Predicate-Factories" class="headerlink" title="Route Predicate Factories"></a>Route Predicate Factories</h2><p>Spring Cloud Gateway将路由匹配作为Spring WebFlux HandlerMapping基础架构的一部分。 Spring Cloud Gateway包括许多内置的Route Predicate工厂。 所有的Predicate都与HTTP请求的不同属性匹配。你可以将多个Route Predicate工厂可以进行逻辑 <code>and</code> 组合，这里有一张图总结了 <code>Spring Cloud</code> 内置的11种 <code>Route Predicate Factory</code> 的作用（有细微变化），详情可参考官网 <a href="https://cloud.spring.io/spring-cloud-gateway/reference/html/#gateway-request-predicates-factories" target="_blank" rel="noopener">Route Predicate Factory官网手册</a></p><p><img alt="spring-cloud-gateway-predicate.png" data-src="https://i.loli.net/2020/02/01/vs1uDdX7lBfyZeH.png" class="lozad"></p><h3 id="时间匹配"><a href="#时间匹配" class="headerlink" title="时间匹配"></a>时间匹配</h3><blockquote><p>包括 <code>After Route Predicate Factory</code>、<code>Before Route Predicate Factory</code>、<code>Between Route Predicate Factory</code></p></blockquote><p>Predicate 支持设置一个时间，在请求进行转发的时候，可以通过判断在这个时间<em>之前</em>或者<em>之后</em>或者<em>之间</em>进行转发。比如这样配置：</p><p><code>After Route Predicate Factory</code>示例：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    gateway:</span></span><br><span class="line"><span class="attr">      routes:</span></span><br><span class="line"><span class="attr">        - id:</span> <span class="string">time_after_route</span></span><br><span class="line"><span class="attr">          uri:</span> <span class="attr">http://www.ityouknow.com/</span></span><br><span class="line"><span class="attr">          predicates:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">Path=/after/**</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">After=2020-02-01T16:50:00+08:00[Asia/Shanghai]</span></span><br></pre></td></tr></table></figure><p>上面的示例是指，请求时间在 <code>2020-02-01 16:50:00</code> 之后的所有请求都转发到地址<code>http://ityouknow.com</code>。+08:00是指时间和 <code>UTC</code> 时间相差八个小时，时间地区为<code>Asia/Shanghai</code>。</p><p>Spring 是通过 ZonedDateTime 来对时间进行的对比，<code>ZonedDateTime</code>是 Java 8 中日期时间功能里，用于表示带时区的日期与时间信息的类，ZonedDateTime 支持通过时区来设置时间，中国的时区是：<code>Asia/Shanghai</code>。</p><p>顾名思义，<code>Before Route Predicate Factory</code> 与上例效果恰好相反：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    gateway:</span></span><br><span class="line"><span class="attr">      routes:</span></span><br><span class="line"><span class="attr">        - id:</span> <span class="string">time_before_route</span></span><br><span class="line"><span class="attr">          uri:</span> <span class="attr">http://www.ityouknow.com/</span></span><br><span class="line"><span class="attr">          predicates:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">Path=/before/**</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">Before=2020-02-01T18:00:00+08:00[Asia/Shanghai]</span></span><br></pre></td></tr></table></figure><p>上面的示例是指，请求时间在 <code>2020-02-01 18:00:00</code> 之前访问 <code>http://localhost:9005/before</code>都会被转发到 <code>http://www.ityouknow.com/</code>。</p><p><code>Between Route Predicate Factory</code>示例：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    gateway:</span></span><br><span class="line"><span class="attr">      routes:</span></span><br><span class="line"><span class="attr">        - id:</span> <span class="string">time_between_route</span></span><br><span class="line"><span class="attr">          uri:</span> <span class="attr">http://www.ityouknow.com/</span></span><br><span class="line"><span class="attr">          predicates:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">Path=/between/**</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">Between=2020-02-01T17:00:00+08:00[Asia/Shanghai],</span> <span class="number">2020</span><span class="bullet">-02</span><span class="bullet">-01</span><span class="attr">T18:00:00+08:00[Asia/Shanghai]</span></span><br></pre></td></tr></table></figure><p>上面的示例是指，在 <code>2020-02-01 17:00:00</code>和<code>2020-02-01 18:00:00</code> 之间请求访问 <code>http://localhost:9005/before</code>都会被转发到 <code>http://www.ityouknow.com/</code>。</p><h3 id="根据-Cookie-匹配"><a href="#根据-Cookie-匹配" class="headerlink" title="根据 Cookie 匹配"></a>根据 Cookie 匹配</h3><p>The Cookie route predicate factory takes two parameters, the cookie name and a regexp (which is a Java regular expression). This predicate matches cookies that have the given name and whose values match the regular expression. The following example configures a cookie route predicate factory</p><p><code>Cookie Route Predicate</code> 可以接收两个参数，一个是 Cookie name ,一个是正则表达式，路由规则会通过获取对应的 Cookie name 值和正则表达式去匹配。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    gateway:</span></span><br><span class="line"><span class="attr">      routes:</span></span><br><span class="line"><span class="attr">      - id:</span> <span class="string">cookie_route</span></span><br><span class="line"><span class="attr">        uri:</span> <span class="attr">https://example.org</span></span><br><span class="line"><span class="attr">        predicates:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">Cookie=chocolate,</span> <span class="string">ch.p</span></span><br></pre></td></tr></table></figure><p>此路由匹配 cookie 名字为 <code>chocolate</code>,匹配值为 <code>ch.p</code> 正则表达式。使用 <code>curl</code> 命令模拟请求：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:9005 --cookie <span class="string">"chocolate=ch.p"</span></span><br></pre></td></tr></table></figure><p>则会返回页面代码，如果去掉 <code>--cookie &quot;chocolate=ch.p&quot;</code>，后台汇报 404 错误。</p><h3 id="根据-Header-属性匹配"><a href="#根据-Header-属性匹配" class="headerlink" title="根据 Header 属性匹配"></a>根据 Header 属性匹配</h3><p><code>Header Route Predicate</code> 和 Cookie Route Predicate 一样，也是接收 2 个参数，一个 Header 中属性名称和一个正则表达式，这个属性值和正则表达式匹配则执行。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    gateway:</span></span><br><span class="line"><span class="attr">      routes:</span></span><br><span class="line"><span class="attr">      - id:</span> <span class="string">header_route</span></span><br><span class="line"><span class="attr">        uri:</span> <span class="attr">https://example.org</span></span><br><span class="line"><span class="attr">        predicates:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">Header=X-Request-Id,</span> <span class="string">\d+</span></span><br></pre></td></tr></table></figure><p>此路由匹配 请求header 中的 name为 <code>X-Request-Id</code>，值为 <code>\d+的正则表达式</code>(只能为一个或多个数字)。</p><p>使用 curl 测试，命令行输入并测试:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:9005 -H <span class="string">"X-Request-Id:996"</span></span><br></pre></td></tr></table></figure><h3 id="根据-Host-匹配"><a href="#根据-Host-匹配" class="headerlink" title="根据 Host 匹配"></a>根据 Host 匹配</h3><p><code>Host Route Predicate Factory</code> 接收一组参数，一组匹配的域名列表，这个模板是一个 ant 分隔的模板，用 <code>.</code> 号作为分隔符。它通过参数中的主机地址作为匹配规则。支持URI模板变量（例如{sub} .myhost.org）</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    gateway:</span></span><br><span class="line"><span class="attr">      routes:</span></span><br><span class="line"><span class="attr">      - id:</span> <span class="string">host_route</span></span><br><span class="line"><span class="attr">        uri:</span> <span class="attr">https://example.org</span></span><br><span class="line"><span class="attr">        predicates:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">Host=**.somehost.org,**.anotherhost.org</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:9005  -H <span class="string">"Host: www.somehost.org"</span></span><br><span class="line">curl http://localhost:9005  -H <span class="string">"Host: beta.anotherhost.org"</span></span><br></pre></td></tr></table></figure><p>此路由可以匹配 Host中的 header 值为 <code>www.somehost.org</code>、<code>beta.somehost.org</code>、<code>www.anotherhost.org</code>。</p><h3 id="根据请求类型匹配"><a href="#根据请求类型匹配" class="headerlink" title="根据请求类型匹配"></a>根据请求类型匹配</h3><p><code>Method Route Predicate Factory</code>,可以根据 <code>POST</code>、<code>GET</code>、<code>PUT</code>、<code>DELETE</code> 等不同的请求类型来进行路由。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    gateway:</span></span><br><span class="line"><span class="attr">      routes:</span></span><br><span class="line"><span class="attr">      - id:</span> <span class="string">method_route</span></span><br><span class="line"><span class="attr">        uri:</span> <span class="attr">https://example.org</span></span><br><span class="line"><span class="attr">        predicates:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">Method=GET,POST</span></span><br></pre></td></tr></table></figure><p>此路由匹配请求方法是<code>GET</code>或<code>POST</code>.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:9005</span><br><span class="line">curl -X POST http://localhost:9005</span><br></pre></td></tr></table></figure><h3 id="根据请求路径匹配"><a href="#根据请求路径匹配" class="headerlink" title="根据请求路径匹配"></a>根据请求路径匹配</h3><p><code>Path Route Predicate Factory</code> 接收一个匹配路径的参数来判断是否走路由。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    gateway:</span></span><br><span class="line"><span class="attr">      routes:</span></span><br><span class="line"><span class="attr">      - id:</span> <span class="string">host_route</span></span><br><span class="line"><span class="attr">        uri:</span> <span class="attr">https://example.org</span></span><br><span class="line"><span class="attr">        predicates:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">Path=/red/&#123;segment&#125;,/blue/&#123;segment&#125;</span></span><br></pre></td></tr></table></figure><p>此路由匹配，例如：<code>/red/1</code> 或 <code>/red/blue</code> 或 <code>/blue/green</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:9005/red/1</span><br></pre></td></tr></table></figure><h3 id="根据请求参数匹配"><a href="#根据请求参数匹配" class="headerlink" title="根据请求参数匹配"></a>根据请求参数匹配</h3><p><code>Query Route Predicate</code> 支持传入两个参数，一个是属性名一个为属性值，属性值可以是正则表达式。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    gateway:</span></span><br><span class="line"><span class="attr">      routes:</span></span><br><span class="line"><span class="attr">      - id:</span> <span class="string">query_route</span></span><br><span class="line"><span class="attr">        uri:</span> <span class="attr">https://example.org</span></span><br><span class="line"><span class="attr">        predicates:</span></span><br><span class="line"><span class="bullet">          -</span> <span class="string">Path=/query/**</span></span><br><span class="line"><span class="bullet">          -</span> <span class="string">Query=color,</span> <span class="string">gree.</span></span><br></pre></td></tr></table></figure><p>此路由匹配请求中，路径前缀为<code>query</code> 且包含 <code>color</code> 属性并且参数值是以 <code>gree开头的长度为五位的字符串</code>才会进行匹配和路由。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:9005/query?color=green</span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    gateway:</span></span><br><span class="line"><span class="attr">      routes:</span></span><br><span class="line"><span class="attr">      - id:</span> <span class="string">query_name_route</span></span><br><span class="line"><span class="attr">        uri:</span> <span class="attr">https://example.org</span></span><br><span class="line"><span class="attr">        predicates:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">Path=/query/**</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">Query=user</span></span><br></pre></td></tr></table></figure><p>此路由匹配请求中 路径前缀为<code>query</code> 且包含 有 <code>user</code> 作为参数名(值可以为空)的请求。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:9005/query?user=</span><br></pre></td></tr></table></figure><h3 id="根据地址进行匹配"><a href="#根据地址进行匹配" class="headerlink" title="根据地址进行匹配"></a>根据地址进行匹配</h3><p><code>RemoteAddr Route Predicate Factory</code> 也支持通过设置某个 ip 区间号段的请求才会路由，它 接受 CIDR(无类别域间路由（Classless Inter-Domain Routing） 符号(IPv4 或 IPv6 )字符串的列表(最小大小为1)，例如 192.168.0.1/16 (其中 192.168.0.1 是 IP 地址，16 是子网掩码)。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    gateway:</span></span><br><span class="line"><span class="attr">      routes:</span></span><br><span class="line"><span class="attr">      - id:</span> <span class="string">remoteaddr_route</span></span><br><span class="line"><span class="attr">        uri:</span> <span class="attr">https://example.org</span></span><br><span class="line"><span class="attr">        predicates:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">RemoteAddr=192.168.1.1/24</span></span><br></pre></td></tr></table></figure><p>此路由匹配远程地址是例如192.168.1.10等</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:9005</span><br></pre></td></tr></table></figure><h3 id="根据权重来访问"><a href="#根据权重来访问" class="headerlink" title="根据权重来访问"></a>根据权重来访问</h3><p><code>Weight Route Predicate Factory</code> 有两个参数，group和weight（一个int）,权重是按组计算的：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    gateway:</span></span><br><span class="line"><span class="attr">      routes:</span></span><br><span class="line"><span class="attr">      - id:</span> <span class="string">weight_high</span></span><br><span class="line"><span class="attr">        uri:</span> <span class="attr">https://weighthigh.org</span></span><br><span class="line"><span class="attr">        predicates:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">Weight=group1,</span> <span class="number">8</span></span><br><span class="line"><span class="attr">      - id:</span> <span class="string">weight_low</span></span><br><span class="line"><span class="attr">        uri:</span> <span class="attr">https://weightlow.org</span></span><br><span class="line"><span class="attr">        predicates:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">Weight=group1,</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>这条路线会将大约80％的流量转发到weighthigh.org，将大约20％的流量转发到weightlow.org</p><h2 id="GatewayFilter"><a href="#GatewayFilter" class="headerlink" title="GatewayFilter"></a>GatewayFilter</h2><p>路由过滤器可用于修改进入的HTTP请求和返回的HTTP响应，路由过滤器只能指定路由进行使用。<code>Spring Cloud Gateway</code> 内置了多种路由过滤器，他们都由 <code>GatewayFilter</code> 的工厂类来产生。由于内置的 <code>GatewayFilter Factories</code> 比较多,详情可参考官网 <a href="https://cloud.spring.io/spring-cloud-gateway/reference/html/#gatewayfilter-factories" target="_blank" rel="noopener">GatewayFilter Factories官网手册</a>。接下来只以 <code>AddRequestHeader GatewayFilter</code>为例介绍：</p><p>在 在两个<code>service-provider</code>(地址为 localhost:9010和9012)的 <code>com.xp.controller.UserController.java</code>中，分别定义一个url:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/req/color"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">(@RequestParam(name = <span class="string">"color"</span>,required = <span class="keyword">false</span>)</span> String color) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"color is "</span> + color + <span class="string">" provider"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/req/color"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">(@RequestParam(name = <span class="string">"color"</span>,required = <span class="keyword">false</span>)</span> String color) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"color is "</span> + color + <span class="string">" provider 2"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后分别重启两个<code>service-provider</code>。</p><p>在 <code>gateway-cloud</code>的 <code>application.yml</code> 中添加如下配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    gateway:</span></span><br><span class="line"><span class="attr">      routes:</span></span><br><span class="line"><span class="attr">        - id:</span> <span class="string">add_request_parameter_route</span></span><br><span class="line"><span class="attr">          uri:</span> <span class="attr">http://localhost:9010/</span></span><br><span class="line"><span class="attr">          filters:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">AddRequestParameter=color,</span> <span class="string">blue</span></span><br><span class="line"><span class="attr">          predicates:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">Method=GET</span></span><br></pre></td></tr></table></figure><p>这样就会给匹配的每个 <code>GET请求</code> 添加上 <code>color=blue</code> 的键值。</p><p>通过浏览器多次访问： <code>http://localhost:9005/req/color</code> 出现：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">color is blue provider</span><br><span class="line">color is blue provider</span><br><span class="line">color is blue provider</span><br></pre></td></tr></table></figure><p>证明网关在转发的过程中已经通过 filter 添加了设置的参数和值（但是都是访问的localhost:9010,也就是 provider1，并没有负载均衡，想要做到负载均衡，uri 的配置栏 必须配置<em>服务名</em>）。</p><h2 id="服务化路由转发"><a href="#服务化路由转发" class="headerlink" title="服务化路由转发"></a>服务化路由转发</h2><p>在 <a href="GatewayFilter">GatewayFilter</a>中我们进行如下配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    gateway:</span></span><br><span class="line"><span class="attr">      routes:</span></span><br><span class="line"><span class="attr">        - id:</span> <span class="string">add_request_parameter_route</span></span><br><span class="line"><span class="attr">          uri:</span> <span class="attr">http://localhost:9010/</span></span><br><span class="line"><span class="attr">          filters:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">AddRequestParameter=color,</span> <span class="string">blue</span></span><br><span class="line"><span class="attr">          predicates:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">Method=GET</span></span><br></pre></td></tr></table></figure><p>由于 uri 配置为 <code>http://localhost:9010/</code> 所以访问时，都是访问 <code>localhost:9010</code>(provider)所在的服务，现在更改配置如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    gateway:</span></span><br><span class="line"><span class="attr">      routes:</span></span><br><span class="line"><span class="attr">        - id:</span> <span class="string">add_request_parameter_route</span></span><br><span class="line">          <span class="comment">#uri: http://localhost:9010/</span></span><br><span class="line">          <span class="comment">#格式为：lb://应用注册服务名</span></span><br><span class="line"><span class="attr">          uri:</span> <span class="attr">lb://SERVICE-PROVIDER</span></span><br><span class="line"><span class="attr">          filters:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">AddRequestParameter=color,</span> <span class="string">blue</span></span><br><span class="line"><span class="attr">          predicates:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">Method=GET</span></span><br></pre></td></tr></table></figure><p>然后再通过浏览器多次访问： <code>http://localhost:9005/req/color</code> 出现：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">color is blue provider</span><br><span class="line">color is blue provider 2</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>provider和provider 2交替出现，说明我们的路由已经服务化，做到了负载均衡。</p><p><a href="https://github.com/Jarvan-IV/spring-cloud-demo" target="_blank" rel="noopener">示例github代码下载</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring Cloud </category>
          
          <category> Spring Cloud Gateway </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring Cloud </tag>
            
            <tag> 微服务 </tag>
            
            <tag> 网关 </tag>
            
            <tag> Spring Cloud Gateway </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cloud 网关Gateway入门</title>
      <link href="/2020/01/30/spring-cloud/Spring%20Cloud%20%E7%BD%91%E5%85%B3Gateway%E5%85%A5%E9%97%A8/"/>
      <url>/2020/01/30/spring-cloud/Spring%20Cloud%20%E7%BD%91%E5%85%B3Gateway%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Cloud-网关Gateway入门"><a href="#Spring-Cloud-网关Gateway入门" class="headerlink" title="Spring Cloud 网关Gateway入门"></a>Spring Cloud 网关Gateway入门</h1><p>Spring Cloud Gateway提供了一个在Spring生态系统之上构建的API网关，包括：Spring 5，Spring Boot 2和Project Reactor。它旨在微服务架构提供一种简单有效的统一的 API 路由管理方式，目标是替代 Netflix Zuul，其不仅提供统一的路由方式，并且基于 Filter 链的方式提供了网关基本的功能，例如：安全、监控、埋点和限流等。</p><ul><li>可以对路由指定 Predicate（断言）和 Filter（过滤器）</li><li>集成Hystrix的断路器功能</li><li>集成 Spring Cloud 服务发现功能</li><li>易于编写的 Predicate（断言）和 Filter（过滤器）</li><li>请求限流功能</li><li>支持路径重写</li></ul><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ul><li>Route（路由）：网关的基本构建块。它由ID，目标URI，一组断言和一组过滤器定义组成。如果断言为真，则路由匹配</li><li>Predicate（断言）：这是<a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html" target="_blank" rel="noopener">Java 8</a>的断言。输入类型是<a href="https://docs.spring.io/spring/docs/5.0.x/javadoc-api/org/springframework/web/server/ServerWebExchange.html" target="_blank" rel="noopener">Spring Framework ServerWebExchange</a>。它可以匹配HTTP请求中的所有内容，例如 请求头或请求参数</li><li>Filter（过滤器）：这是 org.springframework.cloud.gateway.filter.GatewayFilter 的实例，我们可以使用它修改请求和响应。</li></ul><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p>下图概述了Spring Cloud Gateway的工作原理：</p><p><img alt="springcloud gateway.jpg" data-src="https://i.loli.net/2020/01/31/4peEh1DrABvVbRw.jpg" class="lozad"></p><p>客户端向 Spring Cloud Gateway 发出请求。如果在 <code>Gateway Handler Mapping</code> 中找到与请求相匹配的路由，则将其发送到 Gateway Web Handler。Handler 再通过指定的过滤器链来将请求发送到我们实际的服务执行业务逻辑，然后返回。<br>过滤器之间用虚线分开是因为过滤器可能会在发送代理请求之前（“pre”）或之后（“post”）执行业务逻辑</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="在配置文件-yml-中配置"><a href="#在配置文件-yml-中配置" class="headerlink" title="在配置文件 yml 中配置"></a>在配置文件 yml 中配置</h3><p>1、在 <code>spring-cloud-app</code> 项目中创建 子module <code>gateway-cloud</code>：在 pom中添加如下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、在 <code>gateway-cloud</code> 的 <code>application.yml</code> 添加 配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">service-gateway</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    gateway:</span></span><br><span class="line"><span class="attr">      discovery:</span></span><br><span class="line"><span class="attr">        locator:</span></span><br><span class="line"><span class="attr">          enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">      routes:</span></span><br><span class="line"><span class="attr">        - id:</span> <span class="string">add_request_header_route</span></span><br><span class="line"><span class="attr">          uri:</span> <span class="attr">http://jarvan-iv.github.io/2019/10/02/spring%20cloud%E6%9C%8D%E5%8A%A1%E9%97%B4%E8%B0%83%E7%94%A8/</span></span><br><span class="line"><span class="attr">          predicates:</span></span><br><span class="line"><span class="bullet">          -</span> <span class="string">Path=/consumer/**</span></span><br><span class="line">          <span class="comment">#filters:</span></span><br><span class="line">          <span class="comment">#  - AddRequestHeader=X-Request-red, blue</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">9005</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    serviceUrl:</span></span><br><span class="line">      <span class="comment"># eureka-server地址</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://127.0.0.1:8089/eureka/</span></span><br></pre></td></tr></table></figure><blockquote><p>在此之前，首先得启动 eureka-server</p></blockquote><p>配置说明：</p><ul><li><code>spring.cloud.gateway.discovery.locator.enabled</code>:是否与服务注册于发现组件进行结合，通过 <code>serviceId</code> 转发到具体的服务实例。默认为 <code>false</code>，设为 <code>true</code> 便开启通过服务中心的自动根据 <code>serviceId</code> 创建路由的功能。</li><li><code>id</code>：我们自定义的路由 ID，保持唯一。</li><li><code>uri</code>: 目标服务地址。</li><li><code>predicates</code>: 路由条件，Predicate 接受一个输入参数，返回一个布尔值结果。该接口包含多种默认方法来将 Predicate 组合成其他复杂的逻辑（比如：与，或，非）。</li><li><code>filters</code>: 过滤规则。</li></ul><p>上面这段配置的意思是，配置了一个 id 为 <code>add_request_header_route</code> 的路由规则，当访问地址 <code>http://localhost:9005/consumer</code> 时会自动转发到地址：<code>https://jarvan-iv.github.io/2019/10/02/spring%20cloud%E6%9C%8D%E5%8A%A1%E9%97%B4%E8%B0%83%E7%94%A8/</code>。配置完成启动项目即可在浏览器访问进行测试可以正常跳转。</p><p>此外，启动 <code>eureka-server</code> 和 两个<code>service-provider</code>，联系访问 <code>http://localhost:9005/SERVICE-PROVIDER/xiapeng</code>,会得到如下结果：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello，xiapeng，这是provider 提供的信息</span><br><span class="line">hello，xiapeng，这是provider-2 提供的信息</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>说明当 <code>spring.cloud.gateway.discovery.locator.enabled</code> 为 <code>true</code>时，<code>Spring Cloud Gateway</code> 会为我们注册到<code>eureka</code>的服务（<code>service-provider</code>等）自动创建了对应的路由，但是这里的 路径是大写的。通过 <code>http://localhost:9005/SERVICE-PROVIDER/xiapeng</code>就会匹配到 <code>SERVICE-PROVIDER</code>服务对应的 url(<code>/xiapeng</code>)上。</p><p><img alt="eureka注册的服务.jpg" data-src="https://i.loli.net/2020/02/01/Ht2DThdIW81RfPU.jpg" class="lozad"></p><h3 id="通过-Bean自定义-RouteLocator，在启动主类-Application-中配置"><a href="#通过-Bean自定义-RouteLocator，在启动主类-Application-中配置" class="headerlink" title="通过@Bean自定义 RouteLocator，在启动主类 Application 中配置"></a>通过@Bean自定义 RouteLocator，在启动主类 Application 中配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GatewayCloudApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(GatewayCloudApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RouteLocator <span class="title">customRouteLocator</span><span class="params">(RouteLocatorBuilder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> builder.routes()</span><br><span class="line">                .route(<span class="string">"add_request_header_route"</span>, r -&gt; r.path(<span class="string">"/consumer/**"</span>)</span><br><span class="line">                        .uri(<span class="string">"http://jarvan-iv.github.io/2019/10/02/spring%20cloud%E6%9C%8D%E5%8A%A1%E9%97%B4%E8%B0%83%E7%94%A8/"</span>))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码配置和 <code>application.yml</code> 作用等同。</p><p>以上介绍了 <code>Spring Cloud Gateway</code>的基本使用，下一篇介绍它强大的 <code>Route Predicate Factories和GatewayFilter Factories</code></p><p><a href="https://github.com/Jarvan-IV/spring-cloud-demo" target="_blank" rel="noopener">示例github代码下载</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring Cloud </category>
          
          <category> Spring Cloud Gateway </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring Cloud </tag>
            
            <tag> 微服务 </tag>
            
            <tag> 网关 </tag>
            
            <tag> Spring Cloud Gateway </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring cloud 网关初识</title>
      <link href="/2020/01/29/spring-cloud/Spring%20Cloud%20%E7%BD%91%E5%85%B3%E5%88%9D%E8%AF%86/"/>
      <url>/2020/01/29/spring-cloud/Spring%20Cloud%20%E7%BD%91%E5%85%B3%E5%88%9D%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="spring-cloud-网关初识"><a href="#spring-cloud-网关初识" class="headerlink" title="spring cloud 网关初识"></a>spring cloud 网关初识</h1><h2 id="什么是网关"><a href="#什么是网关" class="headerlink" title="什么是网关"></a>什么是网关</h2><p><em>网关</em>是一个<em>抽象层</em>，出现的原因是<em>微服务架构</em>的出现，不同的微服务一般会有不同的网络地址，而外部客户端可能需要调用多个服务的接口才能完成一个业务需求，如果让客户端直接与各个微服务通信，会有以下的问题：</p><ul><li>客户端会多次请求不同的微服务，增加了客户端的复杂性。</li><li>存在跨域请求，在一定场景下处理相对复杂。</li><li>认证复杂，每个服务都需要独立认证。</li><li>难以重构，随着项目的迭代，可能需要重新划分微服务。例如，可能将多个服务合并成一个或者将一个服务拆分成多个。如果客户端直接与微服务通信，那么重构将会很难实施。</li><li>某些微服务可能使用了防火墙/浏览器不友好的协议，直接访问会有一定的困难。</li><li>不利于负载均衡实现。</li></ul><p><img alt="网关.png" data-src="https://i.loli.net/2020/01/31/2bSEAm1ZQUpt4JF.png" class="lozad"></p><p>使用 API 网关后的优点如下：</p><ul><li>简化客户端调用复杂度。</li><li>易于监控。可以在网关收集监控数据并将其推送到外部系统进行分析。</li><li>易于认证。可以在网关上进行认证，然后再将请求转发到后端的微服务，而无须在每个微服务中进行认证。</li><li>减少了客户端与各个微服务之间的直接交互。</li></ul><blockquote><p>在Spring Cloud体系中，网关的实现主要有 Netflix的Zuul和 spring cloud 的gateway，主要功能就是提供负载均衡、反向代理、权限认证等。</p></blockquote><h2 id="Spring-Cloud-Netflix-Zuul"><a href="#Spring-Cloud-Netflix-Zuul" class="headerlink" title="Spring Cloud Netflix Zuul"></a>Spring Cloud Netflix Zuul</h2><p>Spring Cloud Netflix Zuul是由Netflix开源的API网关，在微服务架构下，网关作为对外的门户，实现动态路由、监控、授权、安全、调度等功能。</p><p>1、在 <code>spring-cloud-app</code> 项目中创建 子module <code>gateway-zuul</code>：在 pom中添加如下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--&lt;dependency&gt;</span></span><br><span class="line"><span class="comment">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span></span><br><span class="line"><span class="comment">        &lt;artifactId&gt;spring-cloud-starter-zuul&lt;/artifactId&gt;</span></span><br><span class="line"><span class="comment">        &lt;version&gt;1.4.7.RELEASE&lt;/version&gt;</span></span><br><span class="line"><span class="comment">      &lt;/dependency&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--spring-cloud-starter-netflix-zuul 即为以前的 spring-cloud-starter-zuul--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-zuul<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、在 <code>gateway-zuul</code> 的 <code>application.yml</code> 添加 配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">service-gateway</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">9005</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    serviceUrl:</span></span><br><span class="line">      <span class="comment"># eureka-server地址</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://127.0.0.1:8089/eureka/</span></span><br><span class="line"><span class="attr">zuul:</span></span><br><span class="line"><span class="attr">  routes:</span></span><br><span class="line">    <span class="comment">#这里的配置表示，访问/consumer/** 直接重定向到 http://jarvan-iv.github.io/2019/10/02/spring%20cloud%E6%9C%8D%E5%8A%A1%E9%97%B4%E8%B0%83%E7%94%A8/</span></span><br><span class="line"><span class="attr">    sn:</span></span><br><span class="line"><span class="attr">      path:</span> <span class="string">/consumer/**</span></span><br><span class="line">      <span class="comment"># 跳转到指定 url</span></span><br><span class="line"><span class="attr">      url:</span> <span class="attr">http://jarvan-iv.github.io/2019/10/02/spring%20cloud%E6%9C%8D%E5%8A%A1%E9%97%B4%E8%B0%83%E7%94%A8/</span></span><br></pre></td></tr></table></figure><p>3、启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableZuulProxy</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GatewayZuulApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(GatewayZuulApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、测试</p><p>通过浏览器访问 <code>http://localhost:9005/consumer</code>,发现访问已经被重定向到：<code>https://jarvan-iv.github.io/2019/10/02/spring%20cloud%E6%9C%8D%E5%8A%A1%E9%97%B4%E8%B0%83%E7%94%A8/</code></p><p>5、服务化</p><p>通过url映射的方式来实现zull的转发有局限性，比如每增加一个服务就需要配置一条内容，另外后端的服务如果是动态来提供，就不能采用这种方案来配置了。实际上在实现微服务架构时，服务名与服务实例地址的关系在eureka server中已经存在了，所以只需要将Zuul注册到eureka server上去发现其他服务，就可以实现对serviceId的映射。</p><p>在 pom 中添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--&lt;version&gt;2.1.4.RELEASE&lt;/version&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在 <code>application.yml</code> 添加 配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zuul.routes.xp.path=/producer/**</span><br><span class="line"><span class="comment">#serviceId 为 eureka 注册的 服务名</span></span><br><span class="line">zuul.routes.xp.serviceId=service-provider</span><br></pre></td></tr></table></figure><p>添加后的zuul栏的配置为：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line"><span class="attr">  routes:</span></span><br><span class="line">    <span class="comment">#这里的配置表示，访问/consumer/** 直接重定向到 http://jarvan-iv.github.io/2019/10/02/spring%20cloud%E6%9C%8D%E5%8A%A1%E9%97%B4%E8%B0%83%E7%94%A8/</span></span><br><span class="line"><span class="attr">    sn:</span></span><br><span class="line"><span class="attr">      path:</span> <span class="string">/consumer/**</span></span><br><span class="line">      <span class="comment"># 跳转到指定 url</span></span><br><span class="line"><span class="attr">      url:</span> <span class="attr">http://jarvan-iv.github.io/2019/10/02/spring%20cloud%E6%9C%8D%E5%8A%A1%E9%97%B4%E8%B0%83%E7%94%A8/</span></span><br><span class="line">    <span class="comment">#这里的配置表示，访问/producer/** 直接重定向到 服务service-provider对应的url上</span></span><br><span class="line"><span class="attr">    xp:</span></span><br><span class="line"><span class="attr">      path:</span> <span class="string">/producer/**</span></span><br><span class="line">      <span class="comment">#serviceId 为 eureka 注册的 服务名</span></span><br><span class="line"><span class="attr">      serviceId:</span> <span class="string">service-provider</span></span><br></pre></td></tr></table></figure><p>在此之前，你需要启动 <code>eureka-server</code> 和 <code>service-provider</code>。</p><p>通过浏览器多次访问 <code>http://localhost:9005/producer/xiapeng/</code>,请求会被转发到服务 <code>service-provider</code> 对应的url 上，页面返回：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hello，xiapeng，这是provider 提供的信息</span><br><span class="line">hello，xiapeng，这是provider-2 提供的信息</span><br><span class="line">hello，xiapeng，这是provider 提供的信息</span><br><span class="line">hello，xiapeng，这是provider-2 提供的信息</span><br></pre></td></tr></table></figure><p>说明通过zuul成功调用了 <code>service-provider</code> 服务并且做了均衡负载。</p><p><a href="https://github.com/Jarvan-IV/spring-cloud-demo" target="_blank" rel="noopener">示例代码下载</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring Cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring Cloud </tag>
            
            <tag> 微服务 </tag>
            
            <tag> 网关 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring cloud 熔断器Hystrix</title>
      <link href="/2019/10/11/spring-cloud/spring%20cloud%20%E7%86%94%E6%96%AD%E5%99%A8Hystrix/"/>
      <url>/2019/10/11/spring-cloud/spring%20cloud%20%E7%86%94%E6%96%AD%E5%99%A8Hystrix/</url>
      
        <content type="html"><![CDATA[<h1 id="spring-cloud-熔断器Hystrix"><a href="#spring-cloud-熔断器Hystrix" class="headerlink" title="spring cloud 熔断器Hystrix"></a>spring cloud 熔断器Hystrix</h1><h2 id="雪崩效应"><a href="#雪崩效应" class="headerlink" title="雪崩效应"></a>雪崩效应</h2><p>在微服务架构中通常会有多个服务层调用，基础服务的故障可能会导致级联故障，进而造成整个系统不可用的情况，这种现象被称为服务雪崩效应。服务雪崩效应是一种因“服务提供者”的不可用导致“服务消费者”的不可用,并将不可用逐渐放大的过程。</p><p>如果下图所示：A作为服务提供者，B为A的服务消费者，C和D是B的服务消费者。A不可用引起了B的不可用，并将不可用像滚雪球一样放大到C和D时，雪崩效应就形成了。</p><p><img alt="beda.png" data-src="https://i.loli.net/2019/10/11/NDgTAzduikwboCn.png" class="lozad"></p><h2 id="熔断器（CircuitBreaker）"><a href="#熔断器（CircuitBreaker）" class="headerlink" title="熔断器（CircuitBreaker）"></a>熔断器（CircuitBreaker）</h2><p>熔断器的原理很简单，如同电力过载保护器。它可以实现快速失败，如果它在一段时间内侦测到许多类似的错误，会强迫其以后的多个调用快速失败，不再访问远程服务器，从而防止应用程序不断地尝试执行可能会失败的操作，使得应用程序继续执行而不用等待修正错误，或者浪费CPU时间去等到长时间的超时产生。熔断器也可以使应用程序能够诊断错误是否已经修正，如果已经修正，应用程序会再次尝试调用操作。</p><p>熔断器模式就像是那些容易导致错误的操作的一种代理。这种代理能够记录最近调用发生错误的次数，然后决定使用允许操作继续，或者立即返回错误。 熔断器开关相互转换的逻辑如下图：</p><h2 id="Hystrix特性"><a href="#Hystrix特性" class="headerlink" title="Hystrix特性"></a>Hystrix特性</h2><ul><li>断路器机制</li></ul><p>断路器很好理解, 当Hystrix Command请求后端服务失败数量超过一定比例(默认50%), 断路器会切换到开路状态(Open). 这时所有请求会直接失败而不会发送到后端服务. 断路器保持在开路状态一段时间后(默认5秒), 自动切换到半开路状态(HALF-OPEN). 这时会判断下一次请求的返回情况, 如果请求成功, 断路器切回闭路状态(CLOSED), 否则重新切换到开路状态(OPEN). Hystrix的断路器就像我们家庭电路中的保险丝, 一旦后端服务不可用, 断路器会直接切断请求链, 避免发送大量无效请求影响系统吞吐量, 并且断路器有自我检测并恢复的能力.</p><ul><li>Fallback</li></ul><p>Fallback相当于是降级操作. 对于查询操作, 我们可以实现一个fallback方法, 当请求后端服务出现异常的时候, 可以使用fallback方法返回的值. fallback方法的返回值一般是设置的默认值或者来自缓存.</p><ul><li>资源隔离</li></ul><p>在Hystrix中, 主要通过线程池来实现资源隔离. 通常在使用的时候我们会根据调用的远程服务划分出多个线程池. 例如调用产品服务的Command放入A线程池, 调用账户服务的Command放入B线程池. 这样做的主要优点是运行环境被隔离开了. 这样就算调用服务的代码存在bug或者由于其他原因导致自己所在线程池被耗尽时, 不会对系统的其他服务造成影响. 但是带来的代价就是维护多个线程池会对系统带来额外的性能开销. 如果是对性能有严格要求而且确信自己调用服务的客户端代码不会出问题的话, 可以使用Hystrix的信号模式(Semaphores)来隔离资源.</p><h2 id="Feign-Hystrix"><a href="#Feign-Hystrix" class="headerlink" title="Feign Hystrix"></a>Feign Hystrix</h2><p>因为熔断只是作用在<em>服务调用</em>这一端，因此我们根据上一篇的示例代码只需要改动spring-cloud-consumer项目相关代码就可以。因为，Feign中已经依赖了Hystrix所以在maven配置上不用做任何改动。</p><ol><li>在 <code>service-consumser</code> 的 <code>application.yml</code> 添加 配置：</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line"><span class="attr">  hystrix:</span></span><br><span class="line"><span class="attr">    enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>2.创建失败回调类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloRemoteHystrix</span> <span class="keyword">implements</span> <span class="title">FeginRemoteInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(@RequestParam(value = <span class="string">"name"</span>)</span> String name) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span> +name+<span class="string">", this messge send failed "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.在<strong>调用方的 FeignClient</strong> <code>添加</code>fallback`属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(name = <span class="string">"service-provider"</span>,fallback = HelloRemoteHystrix.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FeginRemoteInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/&#123;name&#125;"</span>)</span><br><span class="line">    <span class="function">String <span class="title">hello</span><span class="params">(@RequestParam(value = <span class="string">"name"</span>)</span> String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.测试，依次启动 <code>eureka-server</code>，<code>service-provider</code>，<code>service-consumer</code>，访问<br><code>http://localhost:9015/fegin/xp</code>，得到结果：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是 通过feigin 调用的接口：hello，xp，这是provider 提供的信息</span><br></pre></td></tr></table></figure><p>当停掉 <code>service-provider</code> 后，继续访问原地址，得到：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是 通过feigin 调用的接口：helloxp, this messge send failed</span><br></pre></td></tr></table></figure><p>根据返回结果说明熔断成功。</p><p><a href="https://github.com/Jarvan-IV/spring-cloud-demo" target="_blank" rel="noopener">示例github代码下载</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring Cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring Cloud </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring cloud服务间调用</title>
      <link href="/2019/10/02/spring-cloud/spring%20cloud%E6%9C%8D%E5%8A%A1%E9%97%B4%E8%B0%83%E7%94%A8/"/>
      <url>/2019/10/02/spring-cloud/spring%20cloud%E6%9C%8D%E5%8A%A1%E9%97%B4%E8%B0%83%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="spring-cloud服务间调用"><a href="#spring-cloud服务间调用" class="headerlink" title="spring cloud服务间调用"></a>spring cloud服务间调用</h1><p>上一篇文章我们介绍了eureka服务注册中心的搭建，这篇文章介绍一下如何利用服务注册中心（<code>eureka-server</code>），搭建一个简单的服务调用案例。</p><p>案例中有三个角色：服务注册中心（<code>eureka-server</code>）、服务提供者（<code>service-provider</code>）、服务消费者（<code>service-consumser</code>），其中服务注册中心用我们上一篇的<code>eureka单机版</code>启动既可，流程是首先启动 <code>eureka-server</code>，然后启动<code>service-provider</code>并注册到<code>eureka-server</code>中，<code>service-consumser</code>从<code>eureka-server</code>中获取服务并调用。</p><blockquote><p>假设你已经读过了上一篇 <code>spring cloud注册中心Eureka</code>，并已经 搭建了 <code>eureka-server</code> 、<code>service-provider</code>、 <code>service-consumser</code> 工程。</p></blockquote><h2 id="service-provider"><a href="#service-provider" class="headerlink" title="service-provider"></a>service-provider</h2><p>在 <code>service-provider</code> 增加一个类 <code>UserController.java</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/&#123;name&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUser</span><span class="params">(@PathVariable(<span class="string">"name"</span>)</span> String name) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello，"</span> + name + <span class="string">"，这是provider 1 提供的信息"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="service-consumser"><a href="#service-consumser" class="headerlink" title="service-consumser"></a>service-consumser</h2><h3 id="通过-RestTemplate-调用service-provider"><a href="#通过-RestTemplate-调用service-provider" class="headerlink" title="通过 RestTemplate 调用service-provider"></a>通过 RestTemplate 调用service-provider</h3><blockquote><p>RestTemplate是一个http请求的客户端工具，它不是类似HttpClient的东东，也不是类似Jackson，jaxb等工具，但它封装了这些工具．是Spring 调用<code>http</code>的client端核心类．顾名思义，与其它template类如JdbcTemplate一样，它封装了与http server的通信的细节，使调用端无须关心http接口响应的消息是什么格式，统统使用Java pojo 来接收请求结果。</p></blockquote><p>在 <code>service-consumser</code> 中 增加类：<code>ConsumerController.java</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"test"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFromProvider</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate().getForObject(<span class="string">"http://localhost:9010/xp"</span>,String.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问 <code>http://localhost:9011/test</code>，会输出：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello，xp，这是provider 提供的信息</span><br></pre></td></tr></table></figure><h3 id="通过-Feign-调用"><a href="#通过-Feign-调用" class="headerlink" title="通过 Feign 调用"></a>通过 Feign 调用</h3><blockquote><p>Feign是一个声明式Web Service客户端。使用Feign能让编写Web Service客户端更加简单, 它的使用方法是定义一个接口，然后在上面添加注解，同时也支持JAX-RS标准的注解。Feign也支持可拔插式的编码器和解码器。Spring Cloud对Feign进行了封装，使其支持了Spring MVC标准注解和HttpMessageConverters。Feign可以与Eureka和Ribbon组合使用以支持负载均衡。</p></blockquote><p>使用Fegin调用服务，需要在<code>service-consumser</code> 中修改以下几处：</p><p>1.在 <code>pom</code> 中增加 fegin 依赖，完整的pom如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--fegin 调用--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--&lt;dependency&gt;</span></span><br><span class="line"><span class="comment">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span></span><br><span class="line"><span class="comment">    &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt;</span></span><br><span class="line"><span class="comment">    &lt;version&gt;1.4.1.RELEASE&lt;/version&gt;</span></span><br><span class="line"><span class="comment">  &lt;/dependency&gt;--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;version&gt;2.1.4.RELEASE&lt;/version&gt;--&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.在启动类 <code>ServiceConsumserApplication.java</code> 增加 <code>@EnableFeignClients</code> 注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceConsumserApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ServiceConsumserApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.编写 fegin client</p><p>增加一个接口 <code>FeginRemoteInterface.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(name = <span class="string">"service-provider"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FeginRemoteInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/&#123;name&#125;"</span>)</span><br><span class="line">    <span class="function">String <span class="title">hello</span><span class="params">(@RequestParam(value = <span class="string">"name"</span>)</span> String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.在 <code>ConsumerController.java</code> 中注入<code>Fegin Client</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> FeginRemoteInterface feginRemoteInterface;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"test"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFromProvider</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate().getForObject(<span class="string">"http://localhost:9010/xp"</span>,String.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/fegin/&#123;name&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserByFegin</span><span class="params">(@PathVariable(<span class="string">"name"</span>)</span> String name) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"这是 通过feigin 调用的接口："</span> + feginRemoteInterface.hello(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="fegin-负载均衡"><a href="#fegin-负载均衡" class="headerlink" title="fegin 负载均衡"></a>fegin 负载均衡</h4><ol><li><p>复制一份 <code>service-provider</code> 工程，命名为 <code>service-provider2</code>,修改 <code>application.yml</code>：中的 <code>server.port</code> 为 <code>9012</code>.</p></li><li><p>修改 <code>service-provider2</code> 的 <code>UserController.java</code>：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/&#123;name&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUser</span><span class="params">(@PathVariable(<span class="string">"name"</span>)</span> String name) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello，"</span> + name + <span class="string">"，这是 provider2 提供的信息"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.启动 <code>service-provider2</code>。<br>此时通过 <code>http://localhost:8087/</code> 访问 <code>eureka-server</code>，会看到如图的效果：</p><p><img alt="注册中心.png" data-src="https://i.loli.net/2019/10/07/ZSDsmcEPwgRJfNe.png" class="lozad"></p><p>可以看到 <code>SERVICE-PROVIDER</code> 服务中有两个 <code>UP</code>（<code>xp:service-provider:9010 , xp:service-provider:9012</code>），表明注册中心有2个 <code>SERVICE-PROVIDER</code> 服务。</p><blockquote><p>由于本人操作的时候，启动 <code>service-provider2</code> 的时候没有更改端口导致 <code>端口被占用</code> 而失败,所以引起了注册中心有 2个 <code>DOWN (1)</code>，不过我们看 注册服务的数量，只看 <code>UP</code>，至于很长时间之后，<code>eureka-server</code> 很长时间都会显示那两个<code>DOWN</code>，这就涉及到知识盲区了？</p></blockquote><p>访问<code>http://localhost:9011/fegin/xp</code>4次数，得到的结果如下:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">这是 通过feigin 调用的接口：hello，xp，这是provider 提供的信息</span><br><span class="line">这是 通过feigin 调用的接口：hello，xp，这是 provider2 提供的信息</span><br><span class="line">这是 通过feigin 调用的接口：hello，xp，这是provider 提供的信息</span><br><span class="line">这是 通过feigin 调用的接口：hello，xp，这是 provider2 提供的信息</span><br></pre></td></tr></table></figure><p>不断的进行测试下去会发现两种结果交替出现，说明两个服务中心自动提供了<code>服务均衡负载</code>的功能。如果我们将服务提供者的数量在提高为N个，测试结果一样，请求会<code>自动轮询</code>到每个服务端来处理。</p><p><a href="https://github.com/Jarvan-IV/spring-cloud-demo" target="_blank" rel="noopener">示例github代码下载</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring Cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring Cloud </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>注册中心Eureka</title>
      <link href="/2019/10/02/spring-cloud/spring%20cloud%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83Eureka/"/>
      <url>/2019/10/02/spring-cloud/spring%20cloud%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83Eureka/</url>
      
        <content type="html"><![CDATA[<h1 id="注册中心Eureka"><a href="#注册中心Eureka" class="headerlink" title="注册中心Eureka"></a>注册中心Eureka</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>Eureka是Netflix开发的基于Http协议的轻量级服务治理中间件，分为服务端和客户端两个部分，服务端提供服务注册与发现能力，客户端SDK提供给微服务使用，简化与服务端的交互。Eureka拥有很多强大的特性，比如动态更新路由配置、集群高可用、分区容错、保证最终一致性等等，基于Http协议的服务器端接口也容易与客户端交互，是一款实现微服务注册中心的理想的中间件。</p></blockquote><h3 id="没有它"><a href="#没有它" class="headerlink" title="没有它"></a>没有它</h3><p>在数年前的SOA时代，服务之间调用通过直接配置IP地址+端口实现，后来服务多了形成了集群，则针对每个服务集群配置一个LVS硬负载，就在服务之间就通过配置硬负载的代理地址+端口实现相互调用。显而易见，这种方式带来的麻烦之处就是随着服务数量的庞大，配置维护工作也越来越麻烦，运维人员每次都得停止服务，修改每个服务实例的配置文件，而后重启服务，工作效率低下且容易出错；如果集群中某些服务是跨机房部署，更是容易受到忽视，从而花费开发和测试人员大量的排查精力。</p><h3 id="拥有他"><a href="#拥有他" class="headerlink" title="拥有他"></a>拥有他</h3><p>Eureka中间件介入之后，就取代了原来服务集群中维护服务路由列表以及选择负载的相关功能，硬负载将被Eureka客户端SDK中软负载算法所取代，而服务的路由配置都将自动注册在Eureka服务端中。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><blockquote><p>项目基于较新的 spring boot 2.x</p></blockquote><p>新建一个项目 <code>spring-cloud-app</code>,这是一个父项目，主要的<code>pom</code> 内容信息如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cloud.version</span>&gt;</span>Greenwich.SR4<span class="tag">&lt;/<span class="name">cloud.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">boot.version</span>&gt;</span>2.1.11.RELEASE<span class="tag">&lt;/<span class="name">boot.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--这儿使用的 spring boot 版本为 2.1.11.RELEASE--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.code.gson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.code.gson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.11.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--这儿使用的 spring-cloud-starter-netflix-eureka 版本为 2.1.4.RELEASE--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--cloud 版本为 Greenwich.SR4--&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--&lt;dependency&gt;</span></span><br><span class="line"><span class="comment">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span></span><br><span class="line"><span class="comment">        &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span></span><br><span class="line"><span class="comment">        &lt;version&gt;$&#123;cloud.version&#125;&lt;/version&gt;</span></span><br><span class="line"><span class="comment">        &lt;type&gt;pom&lt;/type&gt;</span></span><br><span class="line"><span class="comment">        &lt;scope&gt;runtime&lt;/scope&gt;</span></span><br><span class="line"><span class="comment">      &lt;/dependency&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>spring-snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>Spring Snapshots<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo.spring.io/snapshot<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>spring-milestones<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>Spring Milestones<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo.spring.io/milestone<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="eureka-server"><a href="#eureka-server" class="headerlink" title="eureka-server"></a>eureka-server</h3><p>在 <code>spring-cloud-app</code> 中新建 <code>Module</code> 为 <code>eureka-server</code>，<code>pom</code> 依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--eureka-server--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--&lt;version&gt;2.1.4.RELEASE&lt;/version&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>application.yml</code>:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">eureka-server</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8089</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line">    <span class="comment">#表示是否将自己注册到Eureka Server，默认为true。</span></span><br><span class="line"><span class="attr">    register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment">#表示是否从Eureka Server获取注册信息，默认为true。</span></span><br><span class="line"><span class="attr">    fetch-registry:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    serviceUrl:</span></span><br><span class="line">      <span class="comment">#设置与Eureka Server交互的地址，查询服务和注册服务都需要依赖这个地址。默认是http://localhost:8761/eureka ；多个地址可使用 , 分隔。</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:$&#123;server.port&#125;/eureka/</span></span><br></pre></td></tr></table></figure><p>启动，只需要在启动类加上 <code>@EnableEurekaServer</code> 注解即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaServerApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(EurekaServerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问  <code>http://localhost:8089/</code> 即可看到以下页面：</p><p><img alt="EurekaServer.png" data-src="https://i.loli.net/2019/10/07/6wlOhyFuEtBkNxI.png" class="lozad"></p><p>在 <code>Instances currently registered with Eureka</code> 栏下，可看到当前没有 <code>服务</code> 注册到 <code>eureka</code></p><h3 id="service-provider"><a href="#service-provider" class="headerlink" title="service-provider"></a>service-provider</h3><p>在 <code>spring-cloud-app</code> 中新建 <code>Module</code> 为 <code>service-provider</code>，这是模拟服务的提供方，<code>pom</code> 如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--&lt;version&gt;2.1.4.RELEASE&lt;/version&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--&lt;version&gt;2.1.11.RELEASE&lt;/version&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>application.yml</code>:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">service-provider</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">9010</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    serviceUrl:</span></span><br><span class="line">      <span class="comment"># eureka-server地址</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:8089/eureka/</span></span><br></pre></td></tr></table></figure><p>最后在启动类上加上注解 <code>@EnableDiscoveryClient</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceProviderApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ServiceProviderApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候查看注册中心：<br><img alt="service-provider注册.png" data-src="https://i.loli.net/2019/10/07/GmLqkDfzcTVlO42.png" class="lozad"></p><p>会发现注册中心多了一个服务 <code>SERVICE-PROVIDER</code>。</p><h3 id="service-consumser"><a href="#service-consumser" class="headerlink" title="service-consumser"></a>service-consumser</h3><p>在 <code>spring-cloud-app</code> 中新建 <code>Module</code> 为 <code>service-consumser</code>，这是模拟服务的消费方，<code>pom</code> 和 <code>service-provider</code> 一样。</p><p>修改 <code>application.yml</code>:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">service-consumser</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">9011</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    serviceUrl:</span></span><br><span class="line">      <span class="comment"># eureka-server地址</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:8089/eureka/</span></span><br></pre></td></tr></table></figure><p>启动的流程也和 <code>service-provider</code>一样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceConsumserApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查看注册到 eureka-server服务信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dc dc</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> CommandLineRunner</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">CommandLineRunner <span class="title">runner</span><span class="params">(DiscoveryClient dc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> args -&gt; dc.getInstances(<span class="string">"service-provider"</span>)</span><br><span class="line">                .forEach(si -&gt; System.out.println(String.format(</span><br><span class="line">                        <span class="string">"Found %s %s:%s"</span>, si.getServiceId(), si.getHost(), si.getPort())));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ServiceConsumserApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，启动之后 访问 <code>http://localhost:8089/</code> 可以看到 <code>service-consumser</code>服务。</p><h2 id="eureka高可用"><a href="#eureka高可用" class="headerlink" title="eureka高可用"></a>eureka高可用</h2><blockquote><p>注册中心这么关键的服务，如果是单点话，遇到故障就是毁灭性的。在一个分布式系统中，服务注册中心是最重要的基础部分，理应随时处于可以提供服务的状态。为了维持其可用性，使用集群是很好的解决方案。Eureka通过互相注册的方式来实现高可用的部署，所以我们只需要将Eureke Server配置其他可用的serviceUrl就能实现高可用部署。</p></blockquote><h3 id="搭建eureka集群"><a href="#搭建eureka集群" class="headerlink" title="搭建eureka集群"></a>搭建eureka集群</h3><ol><li>只需将<code>eureka-server</code>分别又指向其它两个节点即可，并将 <code>register-with-eureka</code> 和 <code>fetch-registry</code>改为 <code>true</code>，修改后的<code>application.yml</code>如下：</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">eureka-server</span></span><br><span class="line"><span class="attr">  profiles:</span> <span class="string">node1</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8087</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  instance:</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">node1</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line">    <span class="comment">#表示是否将自己注册到Eureka Server，默认为true。</span></span><br><span class="line">    <span class="comment">#register-with-eureka: false</span></span><br><span class="line">    <span class="comment">#表示是否从Eureka Server获取注册信息，默认为true。</span></span><br><span class="line">    <span class="comment">#fetch-registry: false</span></span><br><span class="line"><span class="attr">    serviceUrl:</span></span><br><span class="line">      <span class="comment">#设置与Eureka Server交互的地址，查询服务和注册服务都需要依赖这个地址。默认是http://localhost:8761/eureka ；多个地址可使用 , 分隔。</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://node2:8088/eureka/,http://node3:8089/eureka/</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">eureka-server</span></span><br><span class="line"><span class="attr">  profiles:</span> <span class="string">node2</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8088</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  instance:</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">node2</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line">    <span class="comment">#表示是否将自己注册到Eureka Server，默认为true。</span></span><br><span class="line">    <span class="comment">#register-with-eureka: false</span></span><br><span class="line">    <span class="comment">#表示是否从Eureka Server获取注册信息，默认为true。</span></span><br><span class="line">    <span class="comment">#fetch-registry: false</span></span><br><span class="line"><span class="attr">    serviceUrl:</span></span><br><span class="line">      <span class="comment">#设置与Eureka Server交互的地址，查询服务和注册服务都需要依赖这个地址。默认是http://localhost:8761/eureka ；多个地址可使用 , 分隔。</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://node1:8087/eureka/,http://node3:8089/eureka/</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">eureka-server</span></span><br><span class="line"><span class="attr">  profiles:</span> <span class="string">node3</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8089</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  instance:</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">node3</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line">    <span class="comment">#表示是否将自己注册到Eureka Server，默认为true。</span></span><br><span class="line">    <span class="comment">#register-with-eureka: false</span></span><br><span class="line">    <span class="comment">#表示是否从Eureka Server获取注册信息，默认为true。</span></span><br><span class="line">    <span class="comment">#fetch-registry: false</span></span><br><span class="line"><span class="attr">    serviceUrl:</span></span><br><span class="line">      <span class="comment">#设置与Eureka Server交互的地址，查询服务和注册服务都需要依赖这个地址。默认是http://localhost:8761/eureka ；多个地址可使用 , 分隔。</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://node1:8087/eureka/,http://node2:8088/eureka/</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>2.在 <code>host</code> 中配置：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 node1</span><br><span class="line">127.0.0.1 node2</span><br><span class="line">127.0.0.1 node3</span><br></pre></td></tr></table></figure><p>3.执行命令 <code>mvn package</code>，打包项目后，再运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java -jar eureka-server.jar --spring.profiles.active=node1</span><br><span class="line">java -jar eureka-server.jar --spring.profiles.active=node2</span><br><span class="line">java -jar eureka-server.jar --spring.profiles.active=node3</span><br></pre></td></tr></table></figure><p>4.访问 <code>http://localhost:8087/</code>,结果如图：</p><p><img alt="image.png" data-src="https://i.loli.net/2019/10/07/Omug5XwsRqdHAY8.png" class="lozad"></p><blockquote><p>再集群模式下，需要将 配置 <code>eureka.client.register-with-eureka</code> 和 <code>eureka.client.fetch-registry</code>都设置为 <code>true</code>,也就是默认值。否则这些<code>节点</code>会出现在界面 <code>General Info</code>的 <code>unavailable-replicas</code>中，也就是不可用！</p></blockquote><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p><img alt="34b90774918e4719826d6909b8a1adcd.png" data-src="https://i.loli.net/2019/10/07/MKoItcYUv3XzwDT.png" class="lozad"></p><p>上图更进一步的展示了3个角色之间的交互。</p><ul><li>Service Provider会向Eureka Server做Register（服务注册）、Renew（服务续约）、Cancel（服务下线）等操作。</li><li>Eureka Server之间会做注册服务的同步，从而保证状态一致</li><li>Service Consumer会向Eureka Server获取注册服务列表，并消费服务</li></ul><h3 id="Register"><a href="#Register" class="headerlink" title="Register"></a>Register</h3><p>Register（服务注册），这个接口会在Service Provider启动时被调用来实现服务注册。同时，当Service Provider的服务状态发生变化时（如自身检测认为Down的时候），也会调用来更新服务状态。</p><ul><li><p>ApplicationResource类接收Http服务请求，调用PeerAwareInstanceRegistryImpl的register方法</p></li><li><p>PeerAwareInstanceRegistryImpl完成服务注册后，调用replicateToPeers向其它Eureka Server节点（Peer）做状态同步（异步操作）</p></li></ul><h3 id="Renew"><a href="#Renew" class="headerlink" title="Renew"></a>Renew</h3><p>Renew（服务续约）操作由Service Provider定期调用，类似于heartbeat。主要是用来告诉Eureka Server Service Provider还活着，避免服务被剔除掉。重要参数：</p><ul><li><p><code>instance.leaseRenewalIntervalInSeconds</code>，Renew频率。默认是30秒，也就是每30秒会向Eureka Server发起Renew操作。</p></li><li><p><code>instance.leaseExpirationDurationInSeconds</code>，服务失效时间。默认是90秒，也就是如果Eureka Server在90秒内没有接收到来自Service Provider的Renew操作，就会把Service Provider剔除。</p></li></ul><h3 id="Cancel"><a href="#Cancel" class="headerlink" title="Cancel"></a>Cancel</h3><p>Cancel（服务下线）一般在Service Provider shut down的时候调用，用来把自身的服务从Eureka Server中删除，以防客户端调用不存在的服务。</p><h3 id="Fetch-Registries"><a href="#Fetch-Registries" class="headerlink" title="Fetch Registries"></a>Fetch Registries</h3><p>Fetch Registries由Service Consumer调用，用来获取Eureka Server上注册的服务。<br>为了提高性能，服务列表在Eureka Server会缓存一份，同时每30秒更新一次。</p><h3 id="Eviction"><a href="#Eviction" class="headerlink" title="Eviction"></a>Eviction</h3><p>Eviction（失效服务剔除）用来定期（默认为每60秒）在Eureka Server检测失效的服务，检测标准就是超过一定时间没有Renew的服务。</p><p>默认失效时间为90秒，也就是如果有服务超过90秒没有向Eureka Server发起Renew请求的话，就会被当做失效服务剔除掉。</p><p>失效时间可以通过<code>eureka.instance.leaseExpirationDurationInSeconds</code>进行配置，定期扫描时间可以通过<code>eureka.server.evictionIntervalTimerInMs</code>进行配置。</p><p><a href="https://github.com/Jarvan-IV/spring-cloud-demo" target="_blank" rel="noopener">示例github代码下载</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring Cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring Cloud </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识Spring Cloud</title>
      <link href="/2019/10/02/spring-cloud/%E5%88%9D%E8%AF%86Spring%20Cloud/"/>
      <url>/2019/10/02/spring-cloud/%E5%88%9D%E8%AF%86Spring%20Cloud/</url>
      
        <content type="html"><![CDATA[<h1 id="初识Spring-Cloud"><a href="#初识Spring-Cloud" class="headerlink" title="初识Spring Cloud"></a>初识Spring Cloud</h1><blockquote><p>Spring Cloud provides tools for developers to quickly build some of the common patterns in distributed systems (e.g. configuration management, service discovery, circuit breakers, intelligent routing, micro-proxy, control bus, one-time tokens, global locks, leadership election, distributed sessions, cluster state). Coordination of distributed systems leads to boiler plate patterns, and using Spring Cloud developers can quickly stand up services and applications that implement those patterns. They will work well in any distributed environment, including the developer’s own laptop, bare metal data centres, and managed platforms such as Cloud Foundry.</p></blockquote><blockquote><p>Spring Cloud为开发人员提供了快速构建分布式系统中一些常见模式的工具（例如配置管理，服务发现，断路器，智能路由，微代理，控制总线）。分布式系统的协调导致了样板模式, 使用Spring Cloud开发人员可以快速地支持实现这些模式的服务和应用程序。他们将在任何分布式环境中运行良好，包括开发人员自己的笔记本电脑，裸机数据中心，以及Cloud Foundry等托管平台。</p></blockquote><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>Spring Cloud是一系列框架的有序集合，都可以用Spring Boot的开发风格做到一键启动和部署。Spring并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。</p><p><code>Spring Cloud</code> 专注于提供良好的<code>开箱即用</code>经验的典型用例和<code>可扩展性</code>机制覆盖。</p><ul><li>分布式/版本化配置</li><li>服务注册和发现</li><li>路由</li><li>Service-to-service calls</li><li>负载均衡</li><li>断路器</li><li>分布式消息传递</li></ul><h2 id="核心成员"><a href="#核心成员" class="headerlink" title="核心成员"></a>核心成员</h2><h3 id="Spring-Cloud-Netflix"><a href="#Spring-Cloud-Netflix" class="headerlink" title="Spring Cloud Netflix"></a>Spring Cloud Netflix</h3><p>这可是个大boss，地位仅次于老大，老大各项服务依赖与它，与各种Netflix OSS组件集成，组成微服务的核心，它的小弟主要有Eureka, Hystrix, Zuul, Archaius… 太多了。</p><h4 id="Netflix-Eureka"><a href="#Netflix-Eureka" class="headerlink" title="Netflix Eureka"></a>Netflix Eureka</h4><p>服务中心，云端服务发现，一个基于 REST 的服务，用于定位服务，以实现云端中间层服务发现和故障转移。这个可是springcloud最牛鼻的小弟，服务中心，任何小弟需要其它小弟支持什么都需要从这里来拿，同样的你有什么独门武功的都赶紧过报道，方便以后其它小弟来调用；它的好处是你不需要直接找各种什么小弟支持，只需要到服务中心来领取，也不需要知道提供支持的其它小弟在哪里，还是几个小弟来支持的，反正拿来用就行，服务中心来保证稳定性和质量。</p><h4 id="Netflix-Hystrix"><a href="#Netflix-Hystrix" class="headerlink" title="Netflix Hystrix"></a>Netflix Hystrix</h4><p>熔断器，容错管理工具，旨在通过熔断机制控制服务和第三方库的节点,从而对延迟和故障提供更强大的容错能力。比如突然某个小弟生病了，但是你还需要它的支持，然后调用之后它半天没有响应，你却不知道，一直在等等这个响应；有可能别的小弟也正在调用你的武功绝技，那么当请求多之后，就会发生严重的阻塞影响老大的整体计划。这个时候Hystrix就派上用场了，当Hystrix发现某个小弟不在状态不稳定立马马上让它下线，让其它小弟来顶上来，或者给你说不用等了这个小弟今天肯定不行，该干嘛赶紧干嘛去别在这排队了。</p><h4 id="Netflix-Zuul"><a href="#Netflix-Zuul" class="headerlink" title="Netflix Zuul"></a>Netflix Zuul</h4><p>Zuul 是在云平台上提供动态路由,监控,弹性,安全等边缘服务的框架。Zuul 相当于是设备和 Netflix 流应用的 Web 网站后端所有请求的前门。当其它门派来找大哥办事的时候一定要先经过zuul,看下有没有带刀子什么的给拦截回去，或者是需要找那个小弟的直接给带过去。</p><h4 id="Netflix-Archaius"><a href="#Netflix-Archaius" class="headerlink" title="Netflix Archaius"></a>Netflix Archaius</h4><p>配置管理API，包含一系列配置管理API，提供动态类型化属性、线程安全配置操作、轮询框架、回调机制等功能。可以实现动态获取配置， 原理是每隔60s（默认，可配置）从配置源读取一次内容，这样修改了配置文件后不需要重启服务就可以使修改后的内容生效，前提使用archaius的API来读取。</p><h3 id="Spring-Cloud-Config"><a href="#Spring-Cloud-Config" class="headerlink" title="Spring Cloud Config"></a>Spring Cloud Config</h3><p>配置管理工具包，让你可以把配置放到远程服务器，集中化管理集群配置，目前支持本地存储、Git以及Subversion。</p><h3 id="Spring-Cloud-Bus"><a href="#Spring-Cloud-Bus" class="headerlink" title="Spring Cloud Bus"></a>Spring Cloud Bus</h3><p>事件、消息总线，用于在集群（例如，配置变化事件）中传播状态变化，可与Spring Cloud Config联合实现热部署。</p><h3 id="Spring-Cloud-for-Cloud-Foundry"><a href="#Spring-Cloud-for-Cloud-Foundry" class="headerlink" title="Spring Cloud for Cloud Foundry"></a>Spring Cloud for Cloud Foundry</h3><p>Cloud Foundry是VMware推出的业界第一个开源PaaS云平台，它支持多种框架、语言、运行时环境、云平台及应用服务，使开发人员能够在几秒钟内进行应用程序的部署和扩展，无需担心任何基础架构的问题，其实就是与CloudFoundry进行集成的一套解决方案，抱了Cloud Foundry的大腿。</p><h3 id="Spring-Cloud-Cluster"><a href="#Spring-Cloud-Cluster" class="headerlink" title="Spring Cloud Cluster"></a>Spring Cloud Cluster</h3><p>Spring Cloud Cluster将取代Spring Integration。提供在分布式系统中的集群所需要的基础功能支持，如：选举、集群的状态一致性、全局锁、tokens等常见状态模式的抽象和实现，如果把不同的帮派组织成统一的整体，Spring Cloud Cluster已经帮你提供了很多方便组织成统一的工具。</p><h3 id="Spring-Cloud-Consul"><a href="#Spring-Cloud-Consul" class="headerlink" title="Spring Cloud Consul"></a>Spring Cloud Consul</h3><p><code>Consul</code> 是一个支持多数据中心分布式高可用的服务发现和配置共享的服务软件,由 HashiCorp 公司用 Go 语言开发, 基于 Mozilla Public License 2.0 的协议进行开源. Consul 支持健康检查,并允许 HTTP 和 DNS 协议调用 API 存储键值对，<code>Spring Cloud Consul</code> 封装了Consul操作，consul是一个服务发现与配置工具，与Docker容器可以无缝集成。</p><h3 id="Spring-Cloud-Security"><a href="#Spring-Cloud-Security" class="headerlink" title="Spring Cloud Security"></a>Spring Cloud Security</h3><p>基于spring security的安全工具包，为你的应用程序添加安全控制。这个小弟很牛鼻专门负责整个帮派的安全问题，设置不同的门派访问特定的资源，不能把秘籍葵花宝典泄漏了。</p><h3 id="Spring-Cloud-Sleuth"><a href="#Spring-Cloud-Sleuth" class="headerlink" title="Spring Cloud Sleuth"></a>Spring Cloud Sleuth</h3><p>日志收集工具包，封装了Dapper和log-based追踪以及Zipkin和HTrace操作，为SpringCloud应用实现了一种分布式追踪解决方案。</p><h3 id="Spring-Cloud-Data-Flow"><a href="#Spring-Cloud-Data-Flow" class="headerlink" title="Spring Cloud Data Flow"></a>Spring Cloud Data Flow</h3><p>大数据操作工具，作为Spring XD的替代产品，它是一个混合计算模型，结合了流数据与批量数据的处理方式。</p><h3 id="Spring-Cloud-Stream"><a href="#Spring-Cloud-Stream" class="headerlink" title="Spring Cloud Stream"></a>Spring Cloud Stream</h3><p>Spring Cloud Stream是创建消息驱动微服务应用的框架。Spring Cloud Stream是基于Spring Boot创建，用来建立单独的／工业级spring应用，使用spring integration提供与消息代理之间的连接。数据流操作开发包，封装了与Redis,Rabbit、Kafka等发送接收消息。</p><p>一个业务会牵扯到多个任务，任务之间是通过事件触发的，这就是Spring Cloud stream要干的事了</p><h3 id="Spring-Cloud-Task"><a href="#Spring-Cloud-Task" class="headerlink" title="Spring Cloud Task"></a>Spring Cloud Task</h3><p>主要解决短命微服务的任务管理，任务调度的工作，比如说某些定时任务晚上就跑一次，或者某项数据分析临时就跑几次。</p><h3 id="Spring-Cloud-Zookeeper"><a href="#Spring-Cloud-Zookeeper" class="headerlink" title="Spring Cloud Zookeeper"></a>Spring Cloud Zookeeper</h3><p>ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。ZooKeeper的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户。</p><p>操作Zookeeper的工具包，用于使用zookeeper方式的服务发现和配置管理，抱了Zookeeper的大腿。</p><h3 id="Spring-Cloud-Connectors"><a href="#Spring-Cloud-Connectors" class="headerlink" title="Spring Cloud Connectors"></a>Spring Cloud Connectors</h3><p>Spring Cloud Connectors 简化了连接到服务的过程和从云平台获取操作的过程，有很强的扩展性，可以利用Spring Cloud Connectors来构建你自己的云平台。</p><h3 id="Spring-Cloud-Starters"><a href="#Spring-Cloud-Starters" class="headerlink" title="Spring Cloud Starters"></a>Spring Cloud Starters</h3><p>Spring Boot式的启动项目，为Spring Cloud提供开箱即用的依赖管理。</p><h3 id="Spring-Cloud-CLI"><a href="#Spring-Cloud-CLI" class="headerlink" title="Spring Cloud CLI"></a>Spring Cloud CLI</h3><p>基于 Spring Boot CLI，可以让你以命令行方式快速建立云组件。</p><h2 id="和Spring-Boot-联系"><a href="#和Spring-Boot-联系" class="headerlink" title="和Spring Boot 联系"></a>和Spring Boot 联系</h2><p><code>Spring Boot</code> 是 Spring 的一套快速配置脚手架，<code>Spring Cloud</code>是一个基于<code>Spring Boot</code>实现的云应用开发工具；<code>Spring Boot</code>专注于快速、方便集成的单个个体，Spring Cloud是关注全局的服务治理框架；<code>Spring Boot</code>使用了默认大于配置的理念，很多集成方案已经帮你选择好了，能不配置就不配置，<code>Spring Cloud</code>很大的一部分是基于Spring Boot来实现,可以不基于Spring Boot吗？不可以。</p><p>Spring Boot可以离开Spring Cloud独立使用开发项目，但是Spring Cloud离不开Spring Boot，属于依赖的关系。</p><blockquote><p>spring -&gt; spring boot &gt; Spring Cloud 这样的关系。</p></blockquote><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>Spring Cloud对于中小型互联网公司来说是一种福音，因为这类公司往往没有实力或者没有足够的资金投入去开发自己的分布式系统基础设施，使用Spring Cloud一站式解决方案能在从容应对业务发展的同时大大减少开发成本。同时，随着近几年微服务架构和Docker容器概念的火爆，也会让Spring Cloud在未来越来越“云”化的软件开发风格中立有一席之地，尤其是在目前五花八门的分布式解决方案中提供了标准化的、全站式的技术方案，意义可能会堪比当前Servlet规范的诞生，有效推进服务端软件系统技术水平的进步。</p><p><a href="https://spring.io/projects/spring-cloud" title="spring-cloud" target="_blank" rel="noopener">spring-cloud</a></p><p><a href="https://springcloud.cc/" title="spring-cloud中文文档" target="_blank" rel="noopener">spring-cloud中文文档</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring Cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring Cloud </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程之BlockingQueue</title>
      <link href="/2019/09/22/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BBlockingQueue/"/>
      <url>/2019/09/22/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BBlockingQueue/</url>
      
        <content type="html"><![CDATA[<h1 id="Java多线程之BlockingQueue"><a href="#Java多线程之BlockingQueue" class="headerlink" title="Java多线程之BlockingQueue"></a>Java多线程之BlockingQueue</h1><p> 在JDK1.5新增的Concurrent包中，BlockingQueue很好的解决了多线程中，如何高效安全“传输”数据的问题。通过这些高效并且线程安全的队列类，为我们快速搭建高质量的多线程程序带来极大的便利。本文详细介绍了BlockingQueue家庭中的所有成员，包括他们各自的功能以及常见使用场景。<br>为什么说是阻塞（Blocking）的呢？是因为 BlockingQueue 支持当获取队列元素但是队列为空时，会阻塞等待队列中有元素再返回；也支持添加元素时，如果队列已满，那么等到队列可以放入新元素时再放入。</p><p><img alt="BlockQueque" data-src="https://img-blog.csdnimg.cn/20181105214722458.jpg" class="lozad"></p><table><thead><tr><th>~</th><th>抛异常</th><th>特定值</th><th>阻塞</th><th>超时</th></tr></thead><tbody><tr><td>插入</td><td>add(o)</td><td>offer(o)</td><td>put(o)</td><td>offer(o,timeout,timeUnit)</td></tr><tr><td>移除</td><td>remove(o)</td><td>poll(o)</td><td>take(o)</td><td>poll(timeout,timeunit)</td></tr><tr><td>检查</td><td>element(o)</td><td>peek(o)</td><td>~</td><td>~</td></tr></tbody></table><p>四组不同的行为方式解释：</p><p> -抛异常：如果试图的操作无法立即执行，抛一个异常<br> -特定值：如果试图的操作无法立即执行，返回一个特定的值（一般是 true/false）<br> -阻塞：如果试图的操作无法立即执行，该方法将会发生阻塞，直到能执行<br> -超时：如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行，但等待时间不会超过给定值。返回一个特定的值以告知该操作是否成功。<br>BlockingQueue的核心方法：<br>放入数据：<br>　　offer(anObject):表示如果可能的话,将anObject加到BlockingQueue里,即如果BlockingQueue可以容纳,<br>　　　　则返回true,否则返回false.（本方法不阻塞当前执行方法的线程）<br>　　offer(E o, long timeout, TimeUnit unit),可以设定等待的时间，如果在指定的时间内，还不能往队列中<br>　　　　加入BlockingQueue，则返回失败。<br>　　put(anObject):把anObject加到BlockingQueue里,如果BlockQueue没有空间,则调用此方法的线程被阻断<br>　　　　直到BlockingQueue里面有空间再继续.<br>获取数据：<br>　　poll(time):取走BlockingQueue里排在首位的对象,若不能立即取出,则可以等time参数规定的时间,<br>　　　　取不到时返回null;<br>　　poll(long timeout, TimeUnit unit)：从BlockingQueue取出一个队首的对象，如果在指定时间内，<br>　　　　队列一旦有数据可取，则立即返回队列中的数据。否则知道时间超时还没有数据可取，返回失败。<br>　　take():取走BlockingQueue里排在首位的对象,若BlockingQueue为空,阻断进入等待状态直到<br>　　　　BlockingQueue有新的数据被加入;<br>　　drainTo():一次性从BlockingQueue获取所有可用的数据对象（还可以指定获取数据的个数），<br>　　　　通过该方法，可以提升获取数据效率；不需要多次分批加锁或释放锁。<br>&ensp;&ensp;无法向一个 BlockingQueue 中插入 null。如果你试图插入 null，BlockingQueue 会抛出一个 NullPointerException。可以访问到 BlockingQueue 中的所有元素，而不仅仅是开始和结束的元素。比如说你将一个对象放入队列之中以等待处理，但你的应用想要将其取消掉，那么你可以调用诸如remove(o)方法啦将队列中的特定对象进行移除。但是这么干相率并不高，因此尽量不要用这一类方法，除非迫不得已。</p><h2 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h2><p>基于数组的阻塞队列实现，在ArrayBlockingQueue内部，维护了一个定长数组，以便缓存队列中的数据对象，这是一个常用的阻塞队列，除了一个定长数组外，ArrayBlockingQueue内部还保存着两个整形变量，分别标识着队列的头部和尾部在数组中的位置。</p><p>ArrayBlockingQueue在生产者放入数据和消费者获取数据，都是共用同一个锁对象，由此也意味着两者无法真正并行运行，这点尤其不同于LinkedBlockingQueue；按照实现原理来分析，ArrayBlockingQueue完全可以采用分离锁，从而实现生产者和消费者操作的完全并行运行。Doug Lea之所以没这样去做，也许是因为ArrayBlockingQueue的数据写入和获取操作已经足够轻巧，以至于引入独立的锁机制，除了给代码带来额外的复杂性外，其在性能上完全占不到任何便宜。 ArrayBlockingQueue和LinkedBlockingQueue间还有一个明显的不同之处在于，前者在插入或删除元素时不会产生或销毁任何额外的对象实例，而后者则会生成一个额外的Node对象。这在长时间内需要高效并发地处理大批量数据的系统中，其对于GC的影响还是存在一定的区别。而在创建ArrayBlockingQueue时，我们还可以控制对象的内部锁是否采用公平锁，默认采用非公平锁。<br>ArrayBlockingQueue内部使用可重入锁ReentrantLock + Condition来完成多线程环境的并发操作，内部主要数据如下：</p><p> -items，一个定长数组，维护ArrayBlockingQueue的元素<br> -takeIndex，int，为ArrayBlockingQueue对首位置<br> -putIndex，int，ArrayBlockingQueue对尾位置<br> -count，元素个数<br> -lock，锁，ArrayBlockingQueue出列入列都必须获取该锁，两个步骤公用一个锁<br> -notEmpty，出列条件<br> -notFull，入列条件</p><h2 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h2><p>基于链表的阻塞队列，同ArrayListBlockingQueue类似，其内部也维持着一个数据缓冲队列（该队列由一个链表构成），当生产者往队列中放入一个数据时，队列会从生产者手中获取数据，并缓存在队列内部，而生产者立即返回；只有当队列缓冲区达到最大值缓存容量时（LinkedBlockingQueue可以通过构造函数指定该值），才会阻塞生产者队列，直到消费者从队列中消费掉一份数据，生产者线程会被唤醒，反之对于消费者这端的处理也基于同样的原理。而LinkedBlockingQueue之所以能够高效的处理并发数据，还因为其对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。<br>下面代码演示使用LinkedBlockingQueue来实现生产者消费者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;String&gt; queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_RANGE_FOR_SLEEP = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(BlockingQueue&lt;String&gt; queue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"启动消费者线程！"</span>);</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">boolean</span> isRunning = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (isRunning) &#123;</span><br><span class="line">                System.out.println(<span class="string">"正从队列获取数据..."</span>);</span><br><span class="line">                String data = queue.poll(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != data) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"拿到数据："</span> + data);</span><br><span class="line">                    System.out.println(<span class="string">"正在消费数据："</span> + data);</span><br><span class="line">                    Thread.sleep(r.nextInt(DEFAULT_RANGE_FOR_SLEEP));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 超过2s还没数据，认为所有生产线程都已经退出，自动退出消费线程。</span></span><br><span class="line">                    isRunning = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"退出消费者线程！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> isRunning = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> BlockingQueue queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_RANGE_FOR_SLEEP = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(BlockingQueue queue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String data = <span class="keyword">null</span>;</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        System.out.println(<span class="string">"启动生产者线程！"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (isRunning) &#123;</span><br><span class="line">                System.out.println(<span class="string">"正在生产数据..."</span>);</span><br><span class="line">                Thread.sleep(r.nextInt(DEFAULT_RANGE_FOR_SLEEP));</span><br><span class="line"></span><br><span class="line">                data = <span class="string">"data:"</span> + count.incrementAndGet();</span><br><span class="line">                System.out.println(<span class="string">"将数据："</span> + data + <span class="string">"放入队列..."</span>);</span><br><span class="line">                <span class="keyword">if</span> (!queue.offer(data, <span class="number">2</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"放入数据失败："</span> + data);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"退出生产者线程！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        isRunning = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 声明一个容量为10的缓存队列</span></span><br><span class="line">        BlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        Producer producer1 = <span class="keyword">new</span> Producer(queue);</span><br><span class="line">        Producer producer2 = <span class="keyword">new</span> Producer(queue);</span><br><span class="line">        Producer producer3 = <span class="keyword">new</span> Producer(queue);</span><br><span class="line"></span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> Consumer(queue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 借助Executors</span></span><br><span class="line">        ExecutorService service = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        service.execute(producer1);</span><br><span class="line">        service.execute(producer2);</span><br><span class="line">        service.execute(producer3);</span><br><span class="line">        service.execute(consumer);</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* // 执行20s</span></span><br><span class="line"><span class="comment">        Thread.sleep(20 * 1000);</span></span><br><span class="line"><span class="comment">        producer1.stop();</span></span><br><span class="line"><span class="comment">        producer2.stop();</span></span><br><span class="line"><span class="comment">        producer3.stop();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        Thread.sleep(2000);</span></span><br><span class="line"><span class="comment">        // 退出Executor</span></span><br><span class="line"><span class="comment">        service.shutdown();*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="延迟队列-DelayQueue"><a href="#延迟队列-DelayQueue" class="headerlink" title="延迟队列 DelayQueue"></a>延迟队列 DelayQueue</h2><p>DelayQueue中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。DelayQueue是一个没有大小限制的队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。<br>使用场景：DelayQueue使用场景较少，但都相当巧妙，常见的例子比如使用一个DelayQueue来管理一个超时未响应的连接队列。</p><p>下面以一个网吧上网，时间到自动下机为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayQueueExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        DelayQueue&lt;User&gt; queue = <span class="keyword">new</span> DelayQueue&lt;&gt;();</span><br><span class="line">        User element1 = <span class="keyword">new</span> User(<span class="string">"小明"</span>,<span class="number">8000</span>);</span><br><span class="line">        User element2 = <span class="keyword">new</span> User(<span class="string">"小红"</span>,<span class="number">2000</span>);</span><br><span class="line">        User element3 = <span class="keyword">new</span> User(<span class="string">"小芳"</span>,<span class="number">3000</span>);</span><br><span class="line">        queue.put(element1);</span><br><span class="line">        queue.put(element2);</span><br><span class="line">        queue.put(element3);</span><br><span class="line">        User e = queue.take();</span><br><span class="line">        System.out.println(e.userName + <span class="string">"上网"</span> + e.delayTime + <span class="string">" ms即将下机"</span>);</span><br><span class="line">        User e2 = queue.take();</span><br><span class="line">        System.out.println(e.userName + <span class="string">"上网"</span> + e2.delayTime + <span class="string">" ms即将下机"</span>);</span><br><span class="line">        User e3 = queue.take();</span><br><span class="line">        System.out.println(e.userName + <span class="string">"上网"</span> + e3.delayTime + <span class="string">" ms即将下机"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Delayed</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> delayTime;</span><br><span class="line">    <span class="keyword">long</span> tamp;</span><br><span class="line">    String userName;</span><br><span class="line">    User(String name,<span class="keyword">long</span> delay) &#123;</span><br><span class="line">        delayTime = delay;</span><br><span class="line">        userName = name;</span><br><span class="line">        tamp = delay + System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tamp - System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tamp - ((User) o).tamp &gt; <span class="number">0</span> ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h2><p> 基于优先级的阻塞队列（优先级的判断通过构造函数传入的Compator对象来决定），但需要注意的是PriorityBlockingQueue并不会阻塞数据生产者，而只会在没有可消费的数据时，阻塞数据的消费者。因此使用的时候要特别注意，生产者生产数据的速度绝对不能快于消费者消费数据的速度，否则时间一长，会最终耗尽所有的可用堆内存空间。在实现PriorityBlockingQueue时，内部控制线程同步的锁采用的是公平锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityBlockingQueueTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> PriorityBlockingQueue&lt;User&gt; queue = <span class="keyword">new</span> PriorityBlockingQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        queue.add(<span class="keyword">new</span> User(<span class="number">1</span>, <span class="string">"wu"</span>));</span><br><span class="line">        queue.add(<span class="keyword">new</span> User(<span class="number">5</span>, <span class="string">"wu5"</span>));</span><br><span class="line">        queue.add(<span class="keyword">new</span> User(<span class="number">23</span>, <span class="string">"wu23"</span>));</span><br><span class="line">        queue.add(<span class="keyword">new</span> User(<span class="number">55</span>, <span class="string">"wu55"</span>));</span><br><span class="line">        queue.add(<span class="keyword">new</span> User(<span class="number">9</span>, <span class="string">"wu9"</span>));</span><br><span class="line">        queue.add(<span class="keyword">new</span> User(<span class="number">3</span>, <span class="string">"wu3"</span>));</span><br><span class="line">        <span class="keyword">for</span> (User user : queue) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(queue.take().name);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态内部类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> age, String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> age;</span><br><span class="line">        String name;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(User o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.age &gt; o.age ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h2><p>SynchronousQueue 它的特别之处在于它内部没有容器，一个生产线程，当它生产产品（即put的时候），如果当前没有人想要消费产品(即当前没有线程执行take)，此生产线程必须阻塞，等待一个消费线程调用take操作，take操作将会唤醒该生产线程，同时消费线程会获取生产线程的产品（即数据传递），这样的一个过程称为一次配对过程(当然也可以先take后put,原理是一样的)。</p><p>声明一个SynchronousQueue有两种不同的方式，它们之间有着不太一样的行为。公平模式和非公平模式的区别:<br>如果采用公平模式：SynchronousQueue会采用公平锁，并配合一个FIFO队列来阻塞多余的生产者和消费者，从而体系整体的公平策略；<br>但如果是非公平模式（SynchronousQueue默认）：SynchronousQueue采用非公平锁，同时配合一个LIFO队列来管理多余的生产者和消费者，而后一种模式，如果生产者和消费者的处理速度有差距，则很容易出现饥渴的情况，即可能有某些生产者或者是消费者的数据永远都得不到处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronousQueueExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronousQueueProducer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> BlockingQueue&lt;String&gt; blockingQueue;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SynchronousQueueProducer</span><span class="params">(BlockingQueue&lt;String&gt; queue)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.blockingQueue = queue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String data = UUID.randomUUID().toString();</span><br><span class="line">                    System.out.println(<span class="string">"Put: "</span> + data);</span><br><span class="line">                    blockingQueue.put(data);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronousQueueConsumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> BlockingQueue&lt;String&gt; blockingQueue;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SynchronousQueueConsumer</span><span class="params">(BlockingQueue&lt;String&gt; queue)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.blockingQueue = queue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String data = blockingQueue.take();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()</span><br><span class="line">                            + <span class="string">" take(): "</span> + data);</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> BlockingQueue&lt;String&gt; synchronousQueue = <span class="keyword">new</span> SynchronousQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        SynchronousQueueProducer queueProducer = <span class="keyword">new</span> SynchronousQueueProducer(</span><br><span class="line">                synchronousQueue);</span><br><span class="line">        <span class="keyword">new</span> Thread(queueProducer).start();</span><br><span class="line"></span><br><span class="line">        SynchronousQueueProducer queueProducer1 = <span class="keyword">new</span> SynchronousQueueProducer(</span><br><span class="line">                synchronousQueue);</span><br><span class="line">        <span class="keyword">new</span> Thread(queueProducer1).start();</span><br><span class="line"></span><br><span class="line">        SynchronousQueueConsumer queueConsumer1 = <span class="keyword">new</span> SynchronousQueueConsumer(</span><br><span class="line">                synchronousQueue);</span><br><span class="line">        <span class="keyword">new</span> Thread(queueConsumer1).start();</span><br><span class="line"></span><br><span class="line">        SynchronousQueueConsumer queueConsumer2 = <span class="keyword">new</span> SynchronousQueueConsumer(</span><br><span class="line">                synchronousQueue);</span><br><span class="line">        <span class="keyword">new</span> Thread(queueConsumer2).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br>&ensp;&ensp;Put: 4e698bbf-f34f-425d-bab8-fc0fbd5eacf8<br>&ensp;&ensp;Put: c1d04b80-e8ce-43db-bca4-56b6e8153b67<br>&ensp;&ensp;Thread-2 take(): c1d04b80-e8ce-43db-bca4-56b6e8153b67<br>&ensp;&ensp;Thread-3 take(): 4e698bbf-f34f-425d-bab8-fc0fbd5eacf8<br>&ensp;&ensp;Put: 60d1ff9a-7339-4f3f-b669-c2cc3a93105d<br>&ensp;&ensp;Put: 7b0595b7-54fc-4616-9787-2a22877d24a1<br>&ensp;&ensp;Thread-3 take(): 7b0595b7-54fc-4616-9787-2a22877d24a1<br>&ensp;&ensp;Thread-2 take(): 60d1ff9a-7339-4f3f-b669-c2cc3a93105d</p><p>从运行结果来看，插入数据的线程和获取数据的线程，交替执行。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 线程安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java线程安全之Lock</title>
      <link href="/2019/09/22/Java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B9%8BLock/"/>
      <url>/2019/09/22/Java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B9%8BLock/</url>
      
        <content type="html"><![CDATA[<h1 id="Java线程安全之Lock"><a href="#Java线程安全之Lock" class="headerlink" title="Java线程安全之Lock"></a>Java线程安全之Lock</h1><blockquote><p>在上一篇文章种，简要的介绍了一下synchronized 的使用，在使用synchronized 的代码中，只有等待当前线程执行完，其他的线程才能获取到锁并执行，那么如果多个线程对同一个对象进行读操作，实际上不应该有冲突，但是 synchronized 会导致线程等待并且不可以中断等待（除非线程出现异常）。为了弥补这些问题，Lock横空出世！</p></blockquote><p>Java 5 的 concurrent 包开始提供Lock接口，提供方法主要包括：</p><p> -<code>void lock()</code>：获取锁，如果不能成功获取，则等待，与 synchronized 类似<br> -<code>void lockInterruptibly()</code>：获取锁，如果不能成功获取，则等待，且能够响应中断 t.interrupt()。<br> -<code>boolean tryLock()</code>：获取锁，如果成功，返回 true，如果不成功，返回 false，不等待<br> -<code>boolean tryLock(long time, TimeUnit unit);</code>：在一定的时间内，获取锁，如果成功，返回 true，如果不成功，返回 false，不等待<br> -<code>void unlock();</code>：释放锁<br> -<code>Condition newCondition();</code>：获取等待通知组件，该组件和当前的锁绑定，当前线程只有获得了锁，才能调用该组件的wait()方法，而调用后，当前线程将释放锁。<br>接下来主要介绍2类：ReentrantLock和ReadWriteLock</p><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>当看到ReentrantLock，可能好奇为什么是再入（重入）？它是表示当一个线程试图获取一个它已经获取的锁时，这个获取的动作就自动成功，这是对锁获取粒度的一个概念，也就是锁的持有是以线程为单位而不是基于调用次数。Java锁实现强调再入行是为了和pthread的行为进行区分。</p><p>载入锁可以设置公平性，<code>Lock lock = new ReentrantLock(true);</code>这里所谓的公平性是指在竞争场景中，当公平性为真时，会倾向于将锁赋予等待时间最久的线程。公平性是减少线程”饥饿”（个别线程长期等待锁，但始终无法获取）情况发生的一个办法。如果使用synchronized，我们根本无法进行公平性的选择，其永远是不公平的，这也是主流操作系统调度的选择。通用场景中，公平性未必有想象中的那么重要，Java默认的调度策略很少会导致”饥饿“发生。与此同时，若要保证公平性则会引入额外开销，自然会导致吞吐量下降。所以，只有当你的程序确实有公平需要的时候，才有必要指定它。</p><p>接下来使用ReentrantLock实现一个简单的生产者消费者模型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProduceandConsume</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> full = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//创建一个锁对象</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">//创建两个条件变量，一个为缓冲区非满，一个为缓冲区非空</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = lock.newCondition();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProduceandConsume test2 = <span class="keyword">new</span> ProduceandConsume();</span><br><span class="line">        <span class="keyword">new</span> Thread(test2.new Producer()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(test2.new Consumer()).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(test2.new Producer()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(test2.new Consumer()).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(test2.new Producer()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(test2.new Consumer()).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(test2.new Producer()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(test2.new Consumer()).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//获取锁</span></span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (count == full) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            notFull.await();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    count++;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()</span><br><span class="line">                            + <span class="string">"生产者生产，目前总共有"</span> + count);</span><br><span class="line">                    <span class="comment">//唤醒消费者</span></span><br><span class="line">                    notEmpty.signal();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//释放锁</span></span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            notEmpty.await();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    count--;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()</span><br><span class="line">                            + <span class="string">"消费者消费，目前总共有"</span> + count);</span><br><span class="line">                    notFull.signal();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相对于synchronized，ReentrantLock有以下好处：</p><p> -等待可中断，持有锁的线程长期不释放的时候，正在等待的线程可以选择放弃等待，这相当于Synchronized来说可以避免出现死锁的情况。<br> -公平锁，多个线程等待同一个锁时，必须按照申请锁的时间顺序获得锁，Synchronized锁非公平锁，ReentrantLock默认的构造函数是创建的非公平锁，可以通过参数true设为公平锁，但公平锁表现的性能不是很好。<br> -锁绑定多个条件，一个ReentrantLock对象可以同时绑定对个对象。<br> -可以响应中断请求。<br> -带有超时的获取锁尝试。</p><h2 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h2><p>&ensp;&ensp;读写锁分为读锁和写锁，多个读锁之间是不需要互斥的(读操作不会改变数据，如果上了锁，反而会影响效率)，写锁和写锁之间需要互斥，也就是说，如果只是读数据，就可以多个线程同时读，但是如果你要写数据，就必须互斥，使得同一时刻只有一个线程在操作。示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadWrite</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 共享数据，只能一个线程写数据，可以多个线程读数据 */</span></span><br><span class="line">    <span class="keyword">private</span> Object data = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">/* 创建一个读写锁 */</span></span><br><span class="line">    ReadWriteLock rwlock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读数据，可以多个线程同时读， 所以上读锁即可</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* 上读锁 */</span></span><br><span class="line">        rwlock.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" 准备读数据!"</span>);</span><br><span class="line">            <span class="comment">/* 休眠 */</span></span><br><span class="line">            Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">1000</span>));</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"读出的数据为 :"</span> + data);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwlock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写数据，多个线程不能同时 写 所以必须上写锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Object data)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 上写锁 */</span></span><br><span class="line">        rwlock.writeLock().lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" 准备写数据!"</span>);</span><br><span class="line">            <span class="comment">/* 休眠 */</span></span><br><span class="line">            Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">1000</span>));</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" 写入的数据: "</span> + data);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwlock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Liao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 创建ReadWrite对象 */</span></span><br><span class="line">        <span class="keyword">final</span> ReadWrite readWrite = <span class="keyword">new</span> ReadWrite();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 创建并启动3个读线程 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    readWrite.get();</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*创建3个写线程*/</span></span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">/*随机写入一个数*/</span></span><br><span class="line">                    readWrite.put(<span class="keyword">new</span> Random().nextInt(<span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：<br>&ensp;&ensp;Thread-0 准备读数据!<br>&ensp;&ensp;Thread-2 准备读数据!<br>&ensp;&ensp;Thread-4 准备读数据!<br>&ensp;&ensp;Thread-4读出的数据为 :null<br>&ensp;&ensp;Thread-2读出的数据为 :null<br>&ensp;&ensp;Thread-0读出的数据为 :null<br>&ensp;&ensp;Thread-1 准备写数据!<br>&ensp;&ensp;Thread-1 写入的数据: 2<br>&ensp;&ensp;Thread-3 准备写数据!<br>&ensp;&ensp;Thread-3 写入的数据: 5<br>&ensp;&ensp;Thread-5 准备写数据!<br>&ensp;&ensp;Thread-5 写入的数据: 2</p><p>从第一行到第三行可知，上了读锁之后，有Thread-0  Thread-2 Thread-4 三个线程在同时读数据，三个线程并不是一个执行完才能执行另一个。而进行写操作时，必须等待一个写的线程执行完成之后，另一个线程才能写！ReadLock可以被多个线程持有并且在作用时排斥任何的WriteLock，而WriteLock则是完全的互斥。这一特性最为重要，因为对于高读取频率而相对较低写入的数据结构，使用此类锁同步机制则可以提高并发量。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 线程安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程之线程池</title>
      <link href="/2019/09/22/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2019/09/22/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Java多线程之线程池"><a href="#Java多线程之线程池" class="headerlink" title="Java多线程之线程池"></a>Java多线程之线程池</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>在多线程开发中，如果直接这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">).start();</span><br></pre></td></tr></table></figure><p>如果并发的请求数量非常多，但每个线程执行的时间很短，这样就会频繁的创建和销毁线程，如此一来会大大降低系统的效率。可能出现服务器在为每个请求创建新线程和销毁线程上花费的时间和消耗的系统资源要比处理实际的用户请求的时间和资源更多。同时线程缺乏统一管理，可能无限制新建线程，相互之间竞争，及可能占用过多系统资源导致死机或oom。</p><p>线程池的作用就是线程完一个任务，并不被销毁，而是直接回收。线程池为线程生命周期的开销和资源不足问题提供了解决方案。通过对多个任务重用线程，线程创建的开销被分摊到了多个任务上。有如下好处：</p><p> -重用存在的线程，减少对象创建、消亡的开销，性能佳。<br> -可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。<br> -提供定时执行、定期执行、单线程、并发数控制等功能。</p><h2 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h2><p>Java通过Executors提供四种线程池，分别为：<br> -newFixedThreadPool ：该方法返回一个固定数量的线程池，该方法的线程数始终不变，当有一个任务提交时，若线程池中空闲，则立即执行，若没有，则会被暂缓在一个任务队列中等待有空闲的线程去执行。<br> -newSingleThreadExecutor ：该方法创建一个线程的线程池，若空闲则执行，若没有空闲线程则暂缓在任务队列中。<br> -newCachedThreadPool：该方法返回一个可根据实际情况调整线程个数的线程池，不限制最大线程数量。若有一个任务并且无空闲线程，就会创建一个线程，若有空闲的线程则直接执行任务，若无任务则不创建线程。并且每一个空闲线程会在60s后自动回收。<br> -newScheduledThreadPool ：该方法返回一个ScheduledExecutorService 对象，创建一个定长线程池，支持定时及周期性任务执行。</p><h3 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h3><p>构造器如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h3><p>构造器如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h3><p>构造器如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h3><p>构造器如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> corePoolSize, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize, threadFactory);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">              <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>下面用newScheduledThreadPool实现一个简单的定时任务功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduleThreadPoolDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"定时run"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Task task = <span class="keyword">new</span> Task();</span><br><span class="line">        ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//2秒后开始，没隔5秒执行task</span></span><br><span class="line">        scheduledExecutorService.scheduleWithFixedDelay(task, <span class="number">2</span>, <span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中scheduleWithFixedDelay方法参数如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,</span><br><span class="line">                                                 <span class="keyword">long</span> initialDelay,<span class="keyword">long</span> delay,TimeUnit unit);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> -command：要执行的任务<br> -initialDelay：延迟首次执行时间<br> -delay：延迟间隔时间<br> -unit：时间单位</p><p>上述代码表示：</p><h3 id="自定义线程池（推荐-）"><a href="#自定义线程池（推荐-）" class="headerlink" title="自定义线程池（推荐*****）"></a>自定义线程池（推荐*****）</h3><p>若Executors工厂类无法满足我们的需求，可以自己去创建自定义的线程池，其实Executors工厂类里面的创建线程方法其内部均是用了ThreadPoolExecutor这个类，这个类可以自定义线程，构造方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p> -corePoolSize：核心池的大小，如果调用了prestartAllCoreThreads()或者prestartCoreThread()方法，会直接预先创建corePoolSize的线程（初始化corePoolSize个线程），否则当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中；这样做的好处是，如果任务量很小，那么甚至就不需要缓存任务，corePoolSize的线程就可以应对；<br> -maximumPoolSize：线程池最大线程数，表示在线程池中最多能创建多少个线程，如果运行中的线程超过了这个数字，那么相当于线程池已满，新来的任务会使用RejectedExecutionHandler 进行处理；<br> -keepAliveTime：表示线程没有任务执行时（空闲线程）最多保持多久时间会终止，然后线程池的数目维持在corePoolSize 大小；<br> -unit：持续时间的单位。<br> -workQueue：一个阻塞队列，用来存储等待执行的任务，如果当前对线程的需求超过了corePoolSize大小，才会放在这里；<br> -threadFactory：线程工厂，主要用来创建线程，比如可以指定线程的名字；<br> -handler：拒绝策略，如果线程池已满，新的任务的处理方式</p><p>自定义线程池构造方法的队列是什么类型是很关键的：</p><p> -在使用有界队列（ArrayBlockingQueue）时，若有新的任务需要执行，如果线程池实际线程数小于corePoolSize，则优先创建线程，若大于corePoolSize，则会将任务加入队列等待空闲线程来执行，若队列已满，则在总线程数不大于maximumPoolSize的前提下，创建新的线程，若线程数大于maximumPoolSize，则执行拒绝策略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyTask</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"线程："</span> + Thread.currentThread().getName() + <span class="string">"正在执行"</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">JyThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">            t.setName(<span class="string">"ThreadPoolExecutorDemo thread："</span> + count.getAndAdd(<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyTask myTask1 = <span class="keyword">new</span> MyTask(<span class="string">"任务1"</span>);</span><br><span class="line">        MyTask myTask2 = <span class="keyword">new</span> MyTask(<span class="string">"任务2"</span>);</span><br><span class="line">        MyTask myTask3 = <span class="keyword">new</span> MyTask(<span class="string">"任务3"</span>);</span><br><span class="line">        MyTask myTask4 = <span class="keyword">new</span> MyTask(<span class="string">"任务4"</span>);</span><br><span class="line">        MyTask myTask5 = <span class="keyword">new</span> MyTask(<span class="string">"任务5"</span>);</span><br><span class="line">        MyTask myTask6 = <span class="keyword">new</span> MyTask(<span class="string">"任务6"</span>);</span><br><span class="line">        ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="number">1</span>,<span class="comment">//corePoolSize</span></span><br><span class="line">                <span class="number">2</span>,<span class="comment">//maximumPoolSize</span></span><br><span class="line">                <span class="number">3</span>,<span class="comment">//keepAliveTime</span></span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>),<span class="comment">//队列容量为 3</span></span><br><span class="line">                <span class="keyword">new</span> JyThreadFactory(), <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">        <span class="comment">//执行第一个任务，由于 corePoolSize为1，所以，线程池里面的线程会直接执行myTask1</span></span><br><span class="line">        threadPoolExecutor.execute(myTask1);</span><br><span class="line">        <span class="comment">//执行第二个任务时，由于corePoolSize容量为1，有一个线程正在执行myTask1</span></span><br><span class="line">        <span class="comment">//所以此时的myTask2任务会直接进入队列，此时队列大小为1，</span></span><br><span class="line">        <span class="comment">// 由于队列的容量为3，队列未满，所以此时不会创建线程，而是继续在队列中等待上个任务处理完毕</span></span><br><span class="line">        threadPoolExecutor.execute(myTask2);</span><br><span class="line">        <span class="comment">//此时myTask1仍未处理完毕，所以将任务myTask3放入队列，此时队列大小为2，</span></span><br><span class="line">        <span class="comment">// 没有超过队列的限制容量3，队列未满，所以此时不会创建线程，而是继续在队列中等待上个任务处理完毕</span></span><br><span class="line">        threadPoolExecutor.execute(myTask3);</span><br><span class="line">        <span class="comment">//此时myTask1仍未处理完毕，所以将任务myTask4放入队列，此时队列大小为3，队列刚满</span></span><br><span class="line">        <span class="comment">// 但是没有超过队列的限制容量3，所以此时不会创建线程，而是继续在队列中等待上个任务处理完毕</span></span><br><span class="line">        threadPoolExecutor.execute(myTask4);</span><br><span class="line">        <span class="comment">//此时myTask1仍未处理完毕，所以将任务myTask5放入队列，此时队列大小为4</span></span><br><span class="line">        <span class="comment">//超过了队列的限制容量3，此时创建了一个新的线程，由运行结果看，myTask1和myTask5是同时执行的，</span></span><br><span class="line">        <span class="comment">// 此时，线程池里面总共有2个线程，没有超过maximumPoolSize。</span></span><br><span class="line">        <span class="comment">// 由于创建了一个线程并且从任务队列中取出了一个任务，所以此时队列大小减为3。</span></span><br><span class="line">        threadPoolExecutor.execute(myTask5);</span><br><span class="line">        <span class="comment">//再加入一个新的任务myTask6，此时队列的大小为4，超过了容量限制3，并且线程池里面总的线程数已经达到了maximumPoolSize。</span></span><br><span class="line">        <span class="comment">//所以此时执行任务myTask6会被拒绝策略拒绝。</span></span><br><span class="line">        threadPoolExecutor.execute(myTask6);</span><br><span class="line">        threadPoolExecutor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如图：<br><img alt="有界队列" data-src="https://img-blog.csdnimg.cn/20181111235914957.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTczODk5,size_16,color_FFFFFF,t_70" class="lozad"></p><blockquote><p>运行结果中的打印顺序很重要！！</p></blockquote><p> -无界的任务队列时（LinkedBlockingQueue），与有界队列相比，除非系统资源耗尽，否则无界的任务队列，不存在任务入队失败的情况。当有新任务到来，系统的线程数小于corePoolSize时，则新建线程执行任务。当达到corePoolSize后，就不会继续增加，若后续仍有新的任务加入，而又没有空闲的线程资源，则任务直接进入队列等候，<strong>即maximumPoolSize不起作用</strong>。若任务创建和处理的速度差异很大，无界队列会保持快速增长，直到耗尽系统资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorLinkedDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> taskId;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutorLinkedDemo</span><span class="params">(<span class="keyword">int</span> taskId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.taskId = taskId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"任务："</span>+ taskId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BlockingQueue blockingQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line">        ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="number">2</span>,<span class="comment">//corePoolSize</span></span><br><span class="line">                <span class="number">10</span>,<span class="comment">//maximumPoolSize（linked时无用）</span></span><br><span class="line">                <span class="number">3</span>,<span class="comment">//keepAliveTime</span></span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                blockingQueue,<span class="comment">//队列容量为 3</span></span><br><span class="line">               <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt; <span class="number">8</span>;i++) &#123;</span><br><span class="line">            threadPoolExecutor.execute(<span class="keyword">new</span> ThreadPoolExecutorLinkedDemo(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"队列容量："</span>+blockingQueue.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果图：<br><img alt="运行中打印先后顺序很重要" data-src="https://img-blog.csdnimg.cn/2018111200175986.jpg" class="lozad"></p><blockquote><p>ps：可以通过运行程序，看打印结果得知，线程池中的线程总数是corePoolSize。</p></blockquote><h4 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h4><p>有以下几种：</p><ol><li>在默认的 ThreadPoolExecutor.AbortPolicy 中，处理程序遭到拒绝将抛出运行时RejectedExecutionException。其他任务继续执行。</li><li>在 ThreadPoolExecutor.CallerRunsPolicy 中，线程调用运行该任务的execute 本身。此策略提供简单的反馈控制机制，能够减缓新任务的提交速度。只要线程池未关闭，该策略直接在调用者线程中，运行当前丢弃的任务。</li><li>在 ThreadPoolExecutor.DiscardPolicy中 ，丢弃无法处理的任务，不给予任务处理。</li><li>在 ThreadPoolExecutor.DiscardOldestPolicy 中，如果执行程序尚未关闭，则位于工作队列头部的任务将被删除，然后重试执行程序（如果再次失败，则重复此过程）。即丢弃最老的一个请求，尝试再次提交当前任务。</li><li>自定义拒绝策略，实现RejectedExecutionHandler接口。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 线程安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java I/O之BIO、NIO、AIO</title>
      <link href="/2019/09/22/Java%20I_O%E4%B9%8BBIO%E3%80%81NIO%E3%80%81AIO/"/>
      <url>/2019/09/22/Java%20I_O%E4%B9%8BBIO%E3%80%81NIO%E3%80%81AIO/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-I-O之BIO、NIO、AIO"><a href="#Java-I-O之BIO、NIO、AIO" class="headerlink" title="Java I/O之BIO、NIO、AIO"></a>Java I/O之BIO、NIO、AIO</h1><h2 id="什么是I-O"><a href="#什么是I-O" class="headerlink" title="什么是I/O"></a>什么是I/O</h2><p>I/O就是输入（Input）和输出(Output)，针对不同的操作对象，可以划分为磁盘I/O模型，网络I/O模型，内存映射I/O, Direct I/O、数据库I/O等，只要具有输入输出类型的交互系统都可以认为是I/O系统，也可以说I/O是整个操作系统数据交换与人机交互的通道。一个系统的优化空间，往往都在低效率的I/O环节上。比如数据库查询慢时，我们通常会考虑到建索引，建索引的目的其实也是为了降低I/O次数。正因为如此，Java在I/O上也一直在做持续的优化，从JDK1.4以前的BIO，1.4及其以后的NIO，1.7的AIO。</p><h2 id="BIO（Blocking-I-O）同步阻塞I-O"><a href="#BIO（Blocking-I-O）同步阻塞I-O" class="headerlink" title="BIO（Blocking I/O）同步阻塞I/O"></a>BIO（Blocking I/O）同步阻塞I/O</h2><p>接下来以Socket编程来说明BIO、NIO、AIO的区别<br><strong>BIO Server端代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> PORT = <span class="number">8765</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//try-with-resources</span></span><br><span class="line">        <span class="keyword">try</span>(ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(PORT)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"server start ..."</span>);</span><br><span class="line">            Socket socket = serverSocket.accept();</span><br><span class="line">            <span class="comment">//在使用传统BufferedReader的readLine方法读取时，在该方法成功返回之前，线程被阻塞，客户端读取服务器数据的线程同样会被阻塞。</span></span><br><span class="line">            <span class="comment">// 所以服务器应该为每个socket，开启一个线程</span></span><br><span class="line">            <span class="comment">//每当客户端连接后启动一个线程为该客户端服务</span></span><br><span class="line">            <span class="comment">//可使用线程池代替</span></span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> ServerHandler(socket)).start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>BIO ServerHandler代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerHandler</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServerHandler</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (BufferedReader in = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                <span class="keyword">new</span> InputStreamReader(<span class="keyword">this</span>.socket.getInputStream()))) &#123;</span><br><span class="line">            PrintWriter out = <span class="keyword">new</span> PrintWriter(<span class="keyword">this</span>.socket.getOutputStream(), <span class="keyword">true</span>);</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                String body = in.readLine();</span><br><span class="line">                <span class="keyword">if</span> (body == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"Server：服务器接收到的数据："</span> + body);</span><br><span class="line">                out.println(<span class="string">"这是服务器端响应的数据"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>BIO Client代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String ADDRESS = <span class="string">"127.0.0.1"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> PORT = <span class="number">8765</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (Socket socket = <span class="keyword">new</span> Socket(ADDRESS, PORT)) &#123;</span><br><span class="line">            BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">            PrintWriter out = <span class="keyword">new</span> PrintWriter(socket.getOutputStream(),<span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">//向服务器发送数据</span></span><br><span class="line">            out.println(<span class="string">"向服务器请求数据..."</span>);</span><br><span class="line">            String response = in.readLine();</span><br><span class="line">            System.out.println(<span class="string">"Client：服务器返回数据为："</span> + response);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BIO主要的问题在于不支持太多的客户端连接，每当有一个新的客户端请求接入时，服务端必须创建一个新的线程来处理这条链路，在需要满足高性能、高并发的场景是没法应用的（大量创建新的线程会严重影响服务器性能）。<br><img alt="BIO模型图" data-src="https://img-blog.csdnimg.cn/20181202164559671.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTczODk5,size_16,color_FFFFFF,t_70" class="lozad"></p><h3 id="伪异步I-O编程"><a href="#伪异步I-O编程" class="headerlink" title="伪异步I/O编程"></a>伪异步I/O编程</h3><p>为了解决一个连接一个线程导致创建线程线程过多，影响服务器性能的问题，可使用线程池来管理这些线程，实现伪异步。只需将server端代码修改，再加一个连接池就OK。<br><strong>伪异步 server端代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> PORT = <span class="number">8765</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//try-with-resources</span></span><br><span class="line">        <span class="keyword">try</span>(ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(PORT)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"server start ..."</span>);</span><br><span class="line">            HandlerExecutorPool executorPool = <span class="keyword">new</span> HandlerExecutorPool(<span class="number">50</span>, <span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                Socket socket = serverSocket.accept();</span><br><span class="line">                executorPool.execute(<span class="keyword">new</span> ServerHandler(socket));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>连接池HandlerExecutorPool 代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerExecutorPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ExecutorService executor;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HandlerExecutorPool</span><span class="params">(<span class="keyword">int</span> maxPoolSize, <span class="keyword">int</span> queueSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.executor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                Runtime.getRuntime().availableProcessors(),</span><br><span class="line">                maxPoolSize,</span><br><span class="line">                <span class="number">120L</span>,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(queueSize));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.executor.execute(task);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用线程池可以管理线程（复用），防止线程频繁的创建引起的性能开销，同时也限制了线程的数量，超过最大数量的线程就只能等待，直到线程池中的有空闲的线程可以被复用。所以在大量并发的情况下，读取数据很慢。</p><p><img alt="伪异步" data-src="https://img-blog.csdnimg.cn/20181202172429246.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTczODk5,size_16,color_FFFFFF,t_70" class="lozad"></p><p>关于线程池，可查看我这篇文章：<a href="https://blog.csdn.net/qq_21573899/article/details/83960456" target="_blank" rel="noopener">线程池</a></p><h2 id="NIO-New-I-O-同步非阻塞I-O"><a href="#NIO-New-I-O-同步非阻塞I-O" class="headerlink" title="NIO(New I/O) 同步非阻塞I/O"></a>NIO(New I/O) 同步非阻塞I/O</h2><p>BIO和NIO的区别：其本质就是阻塞和非阻塞的区别。</p><p> -阻塞：应用程序在获取网络数据的时候，如果网络传输数据很慢，那么程序就一直等着，直到传输完毕。<br> -非阻塞：应用程序直接可以获取已经准备就绪好的数据，无需等待。</p><p><img alt="BIO NIO" data-src="https://img-blog.csdnimg.cn/2018120220353379.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTczODk5,size_16,color_FFFFFF,t_70" class="lozad"></p><h3 id="NIO组成"><a href="#NIO组成" class="headerlink" title="NIO组成"></a>NIO组成</h3><ul><li><p>缓冲区 Buffer<br>&ensp;&ensp;在NIO库中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的；在写入数据时，也是写入到缓冲区中。任何时候访问NIO中的数据，都是通过缓冲区进行操作。缓冲区实际上是一个数组，并提供了对数据结构化访问以及维护读写位置等信息。</p><p>具体的缓存区有这些：ByteBuffer、CharBuffer、DoubleBuffer、 FloatBuffer、IntBuffer、 LongBuffer,、ShortBuffer。分别对应byte、char、double、 float、int、 long、 short。他们实现了相同的接口：Buffer。</p></li><li><p>通道 Channel</p></li></ul><p>&ensp;&ensp;我们对数据的读取和写入要通过Channel，它就像水管一样，是一个通道。通道不同于流的地方就是通道是双向的，可以用于读、写和同时读写操作。Channel和IO中的Stream(流)是差不多一个等级的。只不过Stream是单向的，譬如：InputStream, OutputStream。而Channel是双向的，既可以用来进行读操作，又可以用来进行写操作，NIO中的Channel的主要实现有：FileChannel、DatagramChannel、SocketChannel、ServerSocketChannel，分别可以对应文件IO、UDP和TCP（Server和Client）。</p><ul><li>多路复用器 Selector</li></ul><p>&ensp;&ensp;Selector提供选择已经就绪的任务的能力：Selector会不断轮询注册在其上的Channel，如果某个Channel上面发生读或者写事件，这个Channel就处于就绪状态，会被Selector轮询出来，然后通过SelectionKey可以获取就绪Channel的集合，进行后续的I/O操作。<br>&ensp;&ensp;一个Selector可以同时轮询多个Channel，因为JDK使用了epoll()代替传统的select实现，所以没有最大连接句柄1024/2048的限制。所以，只需要一个线程负责Selector的轮询，就可以接入成千上万的客户端。这是Java NIO库的巨大进步。<br>&ensp;&ensp;每个管道都会对选择器进行注册不同的事件状态，以便选择器查找。<br> &ensp;&ensp;SelectionKey.OP_CONNECT、SelectionKey.OP_ACCEPT、SelectionKey.OP_READ、SelectionKey.OP_WRITE</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>服务端实现Server：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1 多路复用器（管理所有的通道）</span></span><br><span class="line">    <span class="keyword">private</span> Selector seletor;</span><br><span class="line">    <span class="comment">//2 建立读缓冲区</span></span><br><span class="line">    <span class="keyword">private</span> ByteBuffer readBuf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">   <span class="comment">//3 建立写缓冲区</span></span><br><span class="line">    <span class="keyword">private</span> ByteBuffer writeBuf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Server</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1 打开路复用器</span></span><br><span class="line">            <span class="keyword">this</span>.seletor = Selector.open();</span><br><span class="line">            <span class="comment">//2 打开服务器通道</span></span><br><span class="line">            ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class="line">            <span class="comment">//3 设置服务器通道为非阻塞模式</span></span><br><span class="line">            ssc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">//4 绑定地址</span></span><br><span class="line">            ssc.bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line">            <span class="comment">//5 把服务器通道注册到多路复用器上，并且监听阻塞事件</span></span><br><span class="line">            ssc.register(<span class="keyword">this</span>.seletor, SelectionKey.OP_ACCEPT);</span><br><span class="line">            System.out.println(<span class="string">"Server start, port :"</span> + port);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//1 必须要让多路复用器开始监听</span></span><br><span class="line">                <span class="keyword">this</span>.seletor.select();</span><br><span class="line">                <span class="comment">//2 返回多路复用器已经选择的结果集</span></span><br><span class="line">                Iterator&lt;SelectionKey&gt; keys = <span class="keyword">this</span>.seletor.selectedKeys().iterator();</span><br><span class="line">                <span class="comment">//3 进行遍历</span></span><br><span class="line">                <span class="keyword">while</span> (keys.hasNext()) &#123;</span><br><span class="line">                    <span class="comment">//4 获取一个选择的元素</span></span><br><span class="line">                    SelectionKey key = keys.next();</span><br><span class="line">                    <span class="comment">//5 直接从容器中移除就可以了</span></span><br><span class="line">                    keys.remove();</span><br><span class="line">                    <span class="comment">//6 如果是有效的</span></span><br><span class="line">                    <span class="keyword">if</span> (key.isValid()) &#123;</span><br><span class="line">                        <span class="comment">//7 如果为阻塞状态</span></span><br><span class="line">                        <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                            <span class="keyword">this</span>.accept(key);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//8 如果为可读状态</span></span><br><span class="line">                        <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                            <span class="keyword">this</span>.read(key);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//9 写数据</span></span><br><span class="line">                        <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">                            <span class="comment">//this.write(key); //ssc</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(SelectionKey key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//ServerSocketChannel ssc =  (ServerSocketChannel) key.channel();</span></span><br><span class="line">        <span class="comment">//ssc.register(this.seletor, SelectionKey.OP_WRITE);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(SelectionKey key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1 清空缓冲区旧的数据</span></span><br><span class="line">            <span class="keyword">this</span>.readBuf.clear();</span><br><span class="line">            <span class="comment">//2 获取之前注册的socket通道对象</span></span><br><span class="line">            SocketChannel sc = (SocketChannel) key.channel();</span><br><span class="line">            <span class="comment">//3 读取数据</span></span><br><span class="line">            <span class="keyword">int</span> count = sc.read(<span class="keyword">this</span>.readBuf);</span><br><span class="line">            <span class="comment">//4 如果没有数据</span></span><br><span class="line">            <span class="keyword">if</span> (count == -<span class="number">1</span>) &#123;</span><br><span class="line">                key.channel().close();</span><br><span class="line">                key.cancel();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//5 有数据则进行读取 读取之前需要进行复位方法(把position 和limit进行复位)</span></span><br><span class="line">            <span class="keyword">this</span>.readBuf.flip();</span><br><span class="line">            <span class="comment">//6 根据缓冲区的数据长度创建相应大小的byte数组，接收缓冲区的数据</span></span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="keyword">this</span>.readBuf.remaining()];</span><br><span class="line">            <span class="comment">//7 接收缓冲区数据</span></span><br><span class="line">            <span class="keyword">this</span>.readBuf.get(bytes);</span><br><span class="line">            <span class="comment">//8 打印结果</span></span><br><span class="line">            String body = <span class="keyword">new</span> String(bytes).trim();</span><br><span class="line">            System.out.println(<span class="string">"Server : "</span> + body);</span><br><span class="line">            <span class="comment">// 9..可以写回给客户端数据</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(SelectionKey key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1 获取服务通道</span></span><br><span class="line">            ServerSocketChannel ssc = (ServerSocketChannel) key.channel();</span><br><span class="line">            <span class="comment">//2 服务器端执行阻塞方法，等待客户端连接，当有客户端连接成功之后，返回这个客户端连接</span></span><br><span class="line">            SocketChannel sc = ssc.accept();</span><br><span class="line">            <span class="comment">//3 设置非阻塞模式</span></span><br><span class="line">            sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">//此时该客户端和服务端已经建立连接</span></span><br><span class="line">            <span class="comment">//4 将客户端SocketChannel注册到多路复用器上，并设置读取标识，下次论询时直接可以读取。</span></span><br><span class="line">            sc.register(<span class="keyword">this</span>.seletor, SelectionKey.OP_READ);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Server(<span class="number">8765</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>客户端实现client：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//需要一个Selector</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建连接的地址</span></span><br><span class="line">        InetSocketAddress address = <span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">8765</span>);</span><br><span class="line">        <span class="comment">//声明连接通道</span></span><br><span class="line">        SocketChannel sc = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//建立缓冲区</span></span><br><span class="line">        ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//打开通道</span></span><br><span class="line">            sc = SocketChannel.open();</span><br><span class="line">            <span class="comment">//进行连接（注册到selector上）</span></span><br><span class="line">            sc.connect(address);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">//定义一个字节数组，然后使用系统录入功能：</span></span><br><span class="line">                <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                System.in.read(bytes);</span><br><span class="line">                <span class="comment">//把数据放到缓冲区中</span></span><br><span class="line">                buf.put(bytes);</span><br><span class="line">                <span class="comment">//对缓冲区进行复位</span></span><br><span class="line">                buf.flip();</span><br><span class="line">                <span class="comment">//写入数据(执行了这个操作，server端的key.isReadable()才是true，才是可读状态)</span></span><br><span class="line">                sc.write(buf);</span><br><span class="line">                <span class="comment">//清空缓冲区数据</span></span><br><span class="line">                buf.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (sc != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sc.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：先启动server，再启动client，client将系统录入的值，发送给server并输出。<br>NIO的运行流程如下：<br><img alt="NIO概述" data-src="https://img-blog.csdnimg.cn/20181202215847951.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTczODk5,size_16,color_FFFFFF,t_70" class="lozad"></p><blockquote><p>本例仅仅是将client端的数据发送给server端，目的是通过API来介绍NIO。</p></blockquote><h2 id="AIO（Asynchronous-I-O）：异步非阻塞I-O"><a href="#AIO（Asynchronous-I-O）：异步非阻塞I-O" class="headerlink" title="AIO（Asynchronous I/O）：异步非阻塞I/O"></a>AIO（Asynchronous I/O）：异步非阻塞I/O</h2><p>&ensp;&ensp;在NIO基础之上引入了异步通道的概念，AIO不需要通过多路复用器对注册的通道进行仑村操作即可实现异步读写，从而简化了NIO编程模型，也称之为NI02.0。AIO的异步特性并不是Java实现的伪异步，而是使用了系统底层API的支持，在Unix系统下，采用了epoll IO模型，而windows便是使用了IOCP模型。<br>AIO和BIO的区别：在于<strong>异步</strong></p><ul><li><p>同步：应用程序会直接参与IO读写操作，并且我们的应用程序会直接阻塞到某一个方法上，直到数据准备就绪；或者采用轮询的策略实时检查数据的就绪状态，如果就绪则获取数据。</p></li><li><p>异步时，则所有的IO读写操作交给操作系统处理，与我们的应用程序没有直接关系，我们程序不需要关心IO读写，当操作系统完成了IO读写操作后，会给应用程序发送信号，此时应用程序直接拿走数据即可。</p></li></ul><p><strong>Server端代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程池</span></span><br><span class="line">    <span class="keyword">private</span> ExecutorService executorService;</span><br><span class="line">    <span class="comment">//线程组</span></span><br><span class="line">    <span class="keyword">private</span> AsynchronousChannelGroup threadGroup;</span><br><span class="line">    <span class="comment">//服务器通道</span></span><br><span class="line">    <span class="keyword">public</span> AsynchronousServerSocketChannel assc;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Server</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建一个缓存池</span></span><br><span class="line">            executorService = Executors.newCachedThreadPool();</span><br><span class="line">            <span class="comment">//创建线程组</span></span><br><span class="line">            threadGroup = AsynchronousChannelGroup.withCachedThreadPool(executorService, <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//创建服务器通道</span></span><br><span class="line">            assc = AsynchronousServerSocketChannel.open(threadGroup);</span><br><span class="line">            <span class="comment">//进行绑定</span></span><br><span class="line">            assc.bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line">            System.out.println(<span class="string">"server start , port : "</span> + port);</span><br><span class="line">            <span class="comment">//进行阻塞</span></span><br><span class="line">            assc.accept(<span class="keyword">this</span>, <span class="keyword">new</span> ServerCompletionHandler());</span><br><span class="line">            <span class="comment">//一直阻塞 不让服务器停止</span></span><br><span class="line">            Thread.sleep(Integer.MAX_VALUE);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Server server = <span class="keyword">new</span> Server(<span class="number">8765</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ServerCompletionHandler端代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerCompletionHandler</span> <span class="keyword">implements</span> <span class="title">CompletionHandler</span>&lt;<span class="title">AsynchronousSocketChannel</span>, <span class="title">Server</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(AsynchronousSocketChannel asc, Server attachment)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当有下一个客户端接入的时候 直接调用Server的accept方法，这样反复执行下去，保证多个客户端都可以阻塞</span></span><br><span class="line">        <span class="comment">//如果注释掉该方法，则只能获取到第一个客户端的数据</span></span><br><span class="line">        attachment.assc.accept(attachment, <span class="keyword">this</span>);</span><br><span class="line">        read(asc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">final</span> AsynchronousSocketChannel asc)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//读取数据</span></span><br><span class="line">        ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        asc.read(buf, buf, <span class="keyword">new</span> CompletionHandler&lt;Integer, ByteBuffer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer resultSize, ByteBuffer attachment)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//进行读取之后,重置标识位</span></span><br><span class="line">                attachment.flip();</span><br><span class="line">                <span class="comment">//获得读取的字节数</span></span><br><span class="line">                System.out.println(<span class="string">"Server -&gt; "</span> + <span class="string">"收到客户端的数据长度为:"</span> + resultSize);</span><br><span class="line">                <span class="comment">//获取读取的数据</span></span><br><span class="line">                String resultData = <span class="keyword">new</span> String(attachment.array()).trim();</span><br><span class="line">                System.out.println(<span class="string">"Server -&gt; "</span> + <span class="string">"收到客户端的数据信息为:"</span> + resultData);</span><br><span class="line">                String response = <span class="string">"服务器响应, 收到了客户端发来的数据: "</span> + resultData;</span><br><span class="line">                write(asc, response);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> </span>&#123;</span><br><span class="line">                exc.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(AsynchronousSocketChannel asc, String response)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            buf.put(response.getBytes());</span><br><span class="line">            buf.flip();</span><br><span class="line">            asc.write(buf).get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, Server attachment)</span> </span>&#123;</span><br><span class="line">        exc.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Client端代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AsynchronousSocketChannel asc;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Client</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        asc = AsynchronousSocketChannel.open();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        asc.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">8765</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            asc.write(ByteBuffer.wrap(request.getBytes())).get();</span><br><span class="line">            read();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            asc.read(buf).get();</span><br><span class="line">            buf.flip();</span><br><span class="line">            <span class="keyword">byte</span>[] respByte = <span class="keyword">new</span> <span class="keyword">byte</span>[buf.remaining()];</span><br><span class="line">            buf.get(respByte);</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(respByte, <span class="string">"utf-8"</span>).trim());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Client c1 = <span class="keyword">new</span> Client();</span><br><span class="line">        c1.connect();</span><br><span class="line">        Client c2 = <span class="keyword">new</span> Client();</span><br><span class="line">        c2.connect();</span><br><span class="line">        Client c3 = <span class="keyword">new</span> Client();</span><br><span class="line">        c3.connect();</span><br><span class="line">        <span class="keyword">new</span> Thread(c1, <span class="string">"c1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(c2, <span class="string">"c2"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(c3, <span class="string">"c3"</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        c1.write(<span class="string">"c1 aaa"</span>);</span><br><span class="line">        c2.write(<span class="string">"c2 bbbb"</span>);</span><br><span class="line">        c3.write(<span class="string">"c3 ccccc"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这儿有一张BIO、NIO、AIO的对比图<br><img alt="对比图" data-src="https://img-blog.csdnimg.cn/20181202232301637.png" class="lozad"></p><blockquote><p>图片来自 <a href="http://blog.anxpp.com/usr/uploads/2016/05/3849862161.png" target="_blank" rel="noopener">http://blog.anxpp.com/usr/uploads/2016/05/3849862161.png</a></p></blockquote><p>一般情况下，我们不需要手动编写NIO、AIO进行通信的代码，他们语法稍显晦涩。如果向进行网络通信，可以考虑更强大、更简单、性能强劲的NIO框架：<strong>Netty</strong>（DubboX、RocketMQ都有使用它）。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> IO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程设计模式之master worker</title>
      <link href="/2019/09/22/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8Bmaster%20worker/"/>
      <url>/2019/09/22/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8Bmaster%20worker/</url>
      
        <content type="html"><![CDATA[<h1 id="Java多线程设计模式之master-worker"><a href="#Java多线程设计模式之master-worker" class="headerlink" title="Java多线程设计模式之master worker"></a>Java多线程设计模式之master worker</h1><h2 id="什么是master-worker"><a href="#什么是master-worker" class="headerlink" title="什么是master worker"></a>什么是master worker</h2><p> Master-Worker 模式是常用的<strong>并行计算模式</strong>。它的核心思想是系统由两类进程协作工作：master进程和worker进程。<strong>master负责接受和分配任务</strong>，worker负责处理子任务。当各个worker子进程处理完成后，会将结果返回给master，由master做归纳和总结。其好处是能将一个大任务分解成若干个小任务，并行执行，从而提高系统的吞吐量。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p><img alt="代码运行图" data-src="https://img-blog.csdnimg.cn/2018121622490453.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTczODk5,size_16,color_FFFFFF,t_70" class="lozad"><br> 任务Task.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Worker：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ConcurrentLinkedQueue&lt;Task&gt; workQueue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; resultMap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CountDownLatch countDownLatch;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(ConcurrentLinkedQueue&lt;Task&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">            Map&lt;String, Object&gt; resultMap, CountDownLatch countDownLatch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">        <span class="keyword">this</span>.resultMap = resultMap;</span><br><span class="line">        <span class="keyword">this</span>.countDownLatch = countDownLatch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Task task = <span class="keyword">this</span>.workQueue.poll();</span><br><span class="line">            <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//真正的业务处理</span></span><br><span class="line">            Object output = handle(task);</span><br><span class="line">            <span class="keyword">this</span>.resultMap.put(<span class="string">"子任务"</span> + task.getId(), output);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.countDownLatch.countDown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//模拟处理任务</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">handle</span><span class="params">(Task task)</span> </span>&#123;</span><br><span class="line">        Object output;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//表示处理task任务的耗时。。。</span></span><br><span class="line">            Thread.sleep(<span class="number">300</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        output = task.getId();</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>master：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Master</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.承装任务的集合</span></span><br><span class="line">    <span class="keyword">private</span> ConcurrentLinkedQueue&lt;Task&gt; workQueue = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();</span><br><span class="line">    <span class="comment">//2.使用HashMap承装所有的worker对象</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Worker&gt; workers = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">//3.使用一个容器承装每一个worker并行执行任务的结果集</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; resultMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">//如果线程池中的线程60s未被使用，将会从线程池中移除</span></span><br><span class="line">    <span class="keyword">private</span> ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Master</span><span class="params">(<span class="keyword">int</span> workerCount, <span class="keyword">final</span> CountDownLatch countDownLatch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; workerCount; i++) &#123;</span><br><span class="line">            <span class="comment">//每一个worker对象都需要有Master的引用workQueue用于任务的领取</span></span><br><span class="line">            <span class="comment">//resultMap用于任务的提交</span></span><br><span class="line">            Worker worker = <span class="keyword">new</span> Worker(<span class="keyword">this</span>.workQueue,<span class="keyword">this</span>.resultMap,countDownLatch);</span><br><span class="line">            <span class="comment">//key表示每一个worker的名字,value表示线程执行对象</span></span><br><span class="line">            workers.put(<span class="string">"子任务"</span> + Integer.toString(i), worker);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.提交方法（将任务提交到任务队列）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submit</span><span class="params">(Task task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.workQueue.add(task);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.需要有一个执行的方法（启动应用程序，让所有的worker工作）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Worker&gt; entry : workers.entrySet()) &#123;</span><br><span class="line">            executorService.execute(entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.返回结果集（汇总逻辑）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : resultMap.entrySet()) &#123;</span><br><span class="line">            ret += (<span class="keyword">int</span>) entry.getValue();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ExecutorService <span class="title">getExecutorService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> executorService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类client：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//保证10个任务线程执行完毕</span></span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">10</span>);</span><br><span class="line">        Master master = <span class="keyword">new</span> Master(<span class="number">10</span>, countDownLatch);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            master.submit(<span class="keyword">new</span> Task(i, <span class="string">"任务"</span> + i));</span><br><span class="line">        &#125;</span><br><span class="line">        master.execute();</span><br><span class="line">        <span class="comment">//阻塞等待任务线程执行完毕</span></span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(</span><br><span class="line">                <span class="string">"最终结果："</span> + master.getResult() + <span class="string">" . 执行耗时 : "</span> + (System.currentTimeMillis()</span><br><span class="line">                        - start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下:</p><p>最终结果：5050 . 执行耗时 : <strong>3003</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Master-Worker模式是一种将串行任务并行化的方案，被分解的子任务在系统中可以被并行处理（子任务是同级别关系，这些子任务独立，谁处理前，谁处理后都没关系）。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 线程安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java线程安全之synchronized</title>
      <link href="/2019/09/22/Java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B9%8Bsynchronized/"/>
      <url>/2019/09/22/Java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B9%8Bsynchronized/</url>
      
        <content type="html"><![CDATA[<h1 id="Java线程安全之synchronized"><a href="#Java线程安全之synchronized" class="headerlink" title="Java线程安全之synchronized"></a>Java线程安全之synchronized</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>synchronized是Java内建得同步机制，所以也有人称其为Intrinsic Locking，它提供了互斥的语义和可见性，当一个线程已经获取到当前锁时，其他试图获取的线程只能等待或者阻塞在那儿。<br>在Java5以前，synchronized是仅有的同步手段，在代码中，synchronized可以用来修饰方法，也可以使用在特定的代码块上，本质上synchronized方法等同于把方法全部语句synchronized块包起来。<br>synchronized是Java中的关键字，是一种同步锁，Monitor是 Java中用以实现线程之间的互斥与协作的主要手段，它可以看成是对象或者 Class的锁。每一个对象都有，也仅有一个 Monitor。它修饰的对象（Monitor）有以下几种：</p><p> -修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象；<br> -修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象；<br> -修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象；<br> -修改一个类，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象。</p><h2 id="作用对象"><a href="#作用对象" class="headerlink" title="作用对象"></a>作用对象</h2><h3 id="修饰一个代码块"><a href="#修饰一个代码块" class="headerlink" title="修饰一个代码块"></a>修饰一个代码块</h3><p>一个线程访问一个对象中的synchronized(this)同步代码块时，其他试图访问该对象的线程将被阻塞。我们看下面一个 Demo1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncMethod</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + (count++));</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写一个运行测试类Client：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CLient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SyncMethod syncMethod = <span class="keyword">new</span> SyncMethod();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(syncMethod, <span class="string">"SyncMethod1"</span>);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(syncMethod, <span class="string">"SyncMethod2"</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：<br>&ensp;&ensp;&ensp;&ensp;SyncMethod1:0<br>&ensp;&ensp;&ensp;&ensp;SyncMethod1:1<br>&ensp;&ensp;&ensp;&ensp;SyncMethod1:2<br>&ensp;&ensp;&ensp;&ensp;SyncMethod1:3<br>&ensp;&ensp;&ensp;&ensp;SyncMethod1:4<br>&ensp;&ensp;&ensp;&ensp;SyncMethod2:5<br>&ensp;&ensp;&ensp;&ensp;SyncMethod2:6<br>&ensp;&ensp;&ensp;&ensp;SyncMethod2:7<br>&ensp;&ensp;&ensp;&ensp;SyncMethod2:8<br>&ensp;&ensp;&ensp;&ensp;SyncMethod2:9</p><p>当两个并发线程(thread1和thread2)访问同一个对象(SyncMethod )中的synchronized代码块时，在同一时刻只能有一个线程得到锁并执行，另一个线程受阻塞，必须等待当前线程执行完这个代码块以后才能执行该代码块。thread1和thread2是互斥的，因为在执行synchronized代码块时，<strong>Monitor（监视器对象）是同一个</strong>，只有执行完该代码块才能释放该对象锁，下一个线程才能得到锁并且执行代码。<br>接下来我们把Client类的代码稍加修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CLient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SyncMethod syncMethod1 = <span class="keyword">new</span> SyncMethod();</span><br><span class="line">        SyncMethod syncMethod2 = <span class="keyword">new</span> SyncMethod();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(syncMethod1, <span class="string">"SyncMethod1"</span>);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(syncMethod2, <span class="string">"SyncMethod2"</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：<br>&ensp;&ensp;&ensp;&ensp;SyncMethod1:0<br>&ensp;&ensp;&ensp;&ensp;SyncMethod2:0<br>&ensp;&ensp;&ensp;&ensp;SyncMethod2:1<br>&ensp;&ensp;&ensp;&ensp;SyncMethod1:1<br>&ensp;&ensp;&ensp;&ensp;SyncMethod2:2<br>&ensp;&ensp;&ensp;&ensp;SyncMethod1:3<br>&ensp;&ensp;&ensp;&ensp;SyncMethod1:5<br>&ensp;&ensp;&ensp;&ensp;SyncMethod2:4<br>&ensp;&ensp;&ensp;&ensp;SyncMethod1:6<br>&ensp;&ensp;&ensp;&ensp;SyncMethod2:7<br>出现以上结果的原因就是，创建了两个SyncMethod的对象syncMethod1 和syncMethod2 ；我们知道synchronized的监视器是对象，这时会有两把锁分别锁定syncMethod1 对象和syncMethod2 对象，而这两把锁是互不干扰的，不形成互斥，简而言之，<strong>synchronized的监视器对象不是同一个</strong>，所以两个线程可以同时执行。</p><h3 id="修饰一个方法"><a href="#修饰一个方法" class="headerlink" title="修饰一个方法"></a>修饰一个方法</h3><p>synchronized修饰一个方法很简单，就是在方法返回值的前面加synchronized，synchronized修饰方法和修饰一个代码块类似，只是作用范围不一样，修饰代码块是大括号括起来的范围，而修饰方法范围是整个方法。如将【Demo1】中的run方法改成如下的方式，实现的效果一样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncMethod</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + (count++));</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现的效果和Demo1是一样的。<br>在用synchronized修饰方法时要注意以下几点：<br> -synchronized关键字不能继承。<br> -在定义接口方法时不能使用synchronized关键字。<br> -构造方法不能使用synchronized关键字，但可以使用synchronized代码块来进行同步。</p><h3 id="修饰一个静态的方法"><a href="#修饰一个静态的方法" class="headerlink" title="修饰一个静态的方法"></a>修饰一个静态的方法</h3><p>我们知道静态方法是属于类的而不属于对象的。同样的，synchronized修饰的静态方法锁定的是这个类的所有对象，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncMethod</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + (count++));</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;编写运行测试类 Client：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CLient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SyncMethod syncMethod1 = <span class="keyword">new</span> SyncMethod();</span><br><span class="line">        SyncMethod syncMethod2 = <span class="keyword">new</span> SyncMethod();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(syncMethod1, <span class="string">"SyncMethod1"</span>);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(syncMethod2, <span class="string">"SyncMethod2"</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：<br>&ensp;&ensp;&ensp;&ensp;SyncMethod1:0<br>&ensp;&ensp;&ensp;&ensp;SyncMethod1:1<br>&ensp;&ensp;&ensp;&ensp;SyncMethod1:2<br>&ensp;&ensp;&ensp;&ensp;SyncMethod1:3<br>&ensp;&ensp;&ensp;&ensp;SyncMethod1:4<br>&ensp;&ensp;&ensp;&ensp;SyncMethod2:5<br>&ensp;&ensp;&ensp;&ensp;SyncMethod2:6<br>&ensp;&ensp;&ensp;&ensp;SyncMethod2:7<br>&ensp;&ensp;&ensp;&ensp;SyncMethod2:8<br>&ensp;&ensp;&ensp;&ensp;SyncMethod2:9</p><p>syncMethod1 和syncMethod1 是SyncMethod的两个对象，但在thread1和thread2并发执行时却保持了线程同步。这是因为method方法中synchronized 修饰的静态方法，静态方法是属于类的，所以锁的Monitor（监视器）是Class字节码，所以这两个线程用了同一把锁。这与Demo1是不同的。</p><h3 id="修饰一个普通的方法"><a href="#修饰一个普通的方法" class="headerlink" title="修饰一个普通的方法"></a>修饰一个普通的方法</h3><p>这和修饰一个静态方法的Monitor级别是一样的，运行结果也是一样的，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncMethod</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SyncMethod.class) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + (count++));</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>现代的（Oracle）JDK中，JVM对此进行了大刀阔斧的改进，提供了三种不同的Monitor实现，也就是常说的三种不同的锁：偏斜锁（Biased Locking）、轻量级锁和重量级锁，大大的改进了其性能。<br>所谓锁的升级、降级，就是JVM优化synchronized 运行的机制，当JVM检测到不同的竞争状况时，会自动切换到合适的锁实现，这种切换就是锁的升级、降级。如果线程执行发生异常，此时JVM会让线程自动释放锁。<br>从性能的角度，synchronized早期的实现比较低效，对比ReentrantLock，大多数场景性能都相差较大。但是在Java  6 种对其进行了非常多的改进，在高竞争情况下，ReentrantLock仍然有一定优势。在大多数情况下，无需纠结于性能，还是考虑代码书写结构的便利性、可维护行，可读性等。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 线程安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程之线程安全</title>
      <link href="/2019/09/22/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
      <url>/2019/09/22/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Java多线程之线程安全"><a href="#Java多线程之线程安全" class="headerlink" title="Java多线程之线程安全"></a>Java多线程之线程安全</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>当多个线程访问某一个类（对象或方法时），这个类始终都能表现出正确的行为，那么这个类（对象或方法）就是线程安全的。</p><h2 id="反例"><a href="#反例" class="headerlink" title="反例"></a>反例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mythread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            count--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"正在执行："</span> + count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Mythread mythread = <span class="keyword">new</span> Mythread();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(mythread,<span class="string">"t1"</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(mythread,<span class="string">"t2"</span>);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(mythread,<span class="string">"t3"</span>);</span><br><span class="line">        Thread t4 = <span class="keyword">new</span> Thread(mythread,<span class="string">"t4"</span>);</span><br><span class="line">        Thread t5 = <span class="keyword">new</span> Thread(mythread,<span class="string">"t5"</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">        t4.start();</span><br><span class="line">        t5.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：<br>&ensp;&ensp;t1正在执行：4<br>&ensp;&ensp;t1正在执行：2<br>&ensp;&ensp;t1正在执行：1<br>&ensp;&ensp;t1正在执行：0<br>&ensp;&ensp;t2正在执行：3</p><blockquote><p>上述代码中，我们的期望结果是 打印count的值应为： 4 3 2 1 0，与预期结果不相符合，所以Mythread这个类线程不安全，简单来讲，就是有多个线程去操作count这个变量，但是count变量的值并不是我们期望的值，这就引发了线程安全的问题。</p></blockquote><h2 id="正例"><a href="#正例" class="headerlink" title="正例"></a>正例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mythread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            count--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"正在执行："</span> + count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Mythread mythread = <span class="keyword">new</span> Mythread();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(mythread,<span class="string">"t1"</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(mythread,<span class="string">"t2"</span>);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(mythread,<span class="string">"t3"</span>);</span><br><span class="line">        Thread t4 = <span class="keyword">new</span> Thread(mythread,<span class="string">"t4"</span>);</span><br><span class="line">        Thread t5 = <span class="keyword">new</span> Thread(mythread,<span class="string">"t5"</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">        t4.start();</span><br><span class="line">        t5.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：<br>&ensp;&ensp;t2正在执行：4<br>&ensp;&ensp;t2正在执行：3<br>&ensp;&ensp;t2正在执行：2<br>&ensp;&ensp;t2正在执行：1<br>&ensp;&ensp;t2正在执行：0</p><blockquote><p>可以在任意对象及方法上加锁，而加锁的代码称为“互斥区”或“临界区”，加了synchronized关键字后，&ensp;&ensp;当多个线程访问MyThead的run方法时，以排队的方式进行处理（这里的排队是按照CPU分配的先后顺序而定的），一个线程想要执行synchronized代码体内容，，必须得等上一个线程执行完，才能拿到锁，如果拿不到锁，这个线程就会不断的尝试获得这把锁，直到拿到为止，而且<strong>多个线程同时去竞争这把锁</strong>。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p> 如果想要达到线程安全，大概有以下办法：</p><p> -封装：通过封装，我们可以将对象内部状态隐藏，保护起来。<br> -不可变</p><p>线程安全需要保证几个基本特征：<br> -原子性：简单说就是相关操作不会中途被其他线程干扰，一般通过同步机制实现。<br> -可见性：是一个线程修改了某个共享变量，其状态能够立即被其他线程知晓，通常被解释为将线程本地状态反映到主内存上。<br> -有序性：是保证线程串行语义，避免指令重排等。</p><p>能够实现线程安全得方法很多，上面synchronized虽然能保证线程安全，但是会导致锁竞争问题，比如，当有100个线程在同时操作一个变量，当线程1执行完毕后，后面的线程2到线程100，一共99个线程，都会去<strong>争夺这一把所，产生非常激烈的锁竞争问题，这可能会导致服务器的CPU使用率过高</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 线程安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程之CountDownLatch、CyclicBarrier和Semaphore</title>
      <link href="/2019/09/21/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BCountDownLatch%E3%80%81CyclicBarrier%E5%92%8CSemaphore/"/>
      <url>/2019/09/21/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BCountDownLatch%E3%80%81CyclicBarrier%E5%92%8CSemaphore/</url>
      
        <content type="html"><![CDATA[<h1 id="Java多线程之CountDownLatch、CyclicBarrier和Semaphore"><a href="#Java多线程之CountDownLatch、CyclicBarrier和Semaphore" class="headerlink" title="Java多线程之CountDownLatch、CyclicBarrier和Semaphore"></a>Java多线程之CountDownLatch、CyclicBarrier和Semaphore</h1><blockquote><p>在java 1.5中，提供了一些非常有用的辅助类来帮助我们进行并发编程，比如CountDownLatch，CyclicBarrier和Semaphore，今天我们就来学习一下这三个辅助类的用法。</p></blockquote><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>CountDownLatch是一个同步工具类，它允许一个或多个线程一直等待，直到其他线程的操作执行完后再执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDown = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"进入t1线程，等待其他线程初始化。。。。"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                countDown.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"t1线程执行完毕。。"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"进入t2线程。。。。"</span>);</span><br><span class="line">            countDown.countDown();</span><br><span class="line">            System.out.println(<span class="string">"t2线程执行完毕。。"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"进入t3线程。。。。"</span>);</span><br><span class="line">            countDown.countDown();</span><br><span class="line">            System.out.println(<span class="string">"t3线程执行完毕。。"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：<br><img alt="countdown" data-src="https://img-blog.csdnimg.cn/20181111102341167.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTczODk5,size_16,color_FFFFFF,t_70" class="lozad"></p><p>CountDownLatch是通过一个计数器来实现的，计数器的初始值为线程的数量（构造器中传入）。每当一个线程完成了自己的任务后，计数器的值就会减1。当计数器值到达0时，它表示所有的线程已经完成了任务，然后在闭锁上等待的线程就可以恢复执行任务。</p><p>构造器中的计数值（count）实际上就是闭锁需要等待的线程数量。这个值只能被设置一次，而且CountDownLatch没有提供任何机制去重新设置这个计数值。</p><p>与CountDownLatch的第一次交互是主线程等待其他线程。主线程必须在启动其他线程后立即调用CountDownLatch.await()方法。这样主线程的操作就会在这个方法上阻塞，直到其他线程完成各自的任务。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>&ensp;&ensp;&ensp;&ensp;比如我们现在需要做一道菜，叫做<strong>开水煮白菜</strong>（自创的。。。哈哈），假设步骤如下：首先，将水烧开（需要3秒），然后将白菜倒入已烧开的水中（需要5秒）。这时，烧水的过程和洗菜的过程，完全可以同时进行。用代码描述如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">//开水煮白菜</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDown = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">long</span> time = System.currentTimeMillis();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"正在烧水。。。。。"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"水已烧开。。蔬菜可以下锅"</span>);</span><br><span class="line">            countDown.countDown();</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        System.out.println(<span class="string">"正在清洗白菜。。。。"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"白菜清洗完毕。。。。"</span>);</span><br><span class="line">        countDown.await();</span><br><span class="line">        System.out.println(<span class="string">"将白菜倒入沸水中"</span> + <span class="string">" 共耗时："</span> + (System.currentTimeMillis() - time));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：<br><img alt="demo" data-src="https://img-blog.csdnimg.cn/20181111113258421.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTczODk5,size_16,color_FFFFFF,t_70" class="lozad"></p><p>跟以上案例比较接近的时候，比如我们在使用zookeeper的zkclient的时候，首先开启一个线程建立zookeeper的连接，然后就是在获取到连接之后，再对zookeeper的节点进行操作。这里的建立连接就好比上面场景的烧开水；对节点进行操作就好比洗白菜；当连接建立之后，就直接执行操作节点的指令，好比将白菜倒入沸水。</p><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p>字面意思回环栅栏，<strong>通过它可以实现让一组线程等待至某个状态之后再全部同时执行</strong>。叫做回环是因为当所有等待线程都被释放以后，CyclicBarrier可以被重用。我们暂且把这个状态就叫做barrier，当调用await()方法之后，线程就处于barrier了。<br>CyclicBarrier提供2个构造器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>参数parties指让多少个线程或者任务等待至barrier状态；参数barrierAction为当这些线程都达到barrier状态时会执行的内容。</p><p>然后CyclicBarrier中最重要的方法就是await方法，它有2个重载版本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException,BrokenBarrierException,</span></span><br><span class="line"><span class="function">               TimeoutException </span>&#123;&#125;</span><br></pre></td></tr></table></figure><ol><li>第一个版本比较常用，用来挂起当前线程，直至所有线程都到达barrier状态再同时执行后续任务；</li><li>第二个版本是让这些线程等待至一定的时间，如果还有线程没有到达barrier状态就直接让到达barrier的线程执行后续任务。<br>以运动员跑步为例，当裁判的枪声一响，所有的运动员就全部一起跑，这时，啦啦队开始加油！。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Runner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> CyclicBarrier cyclicBarrier;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Runner</span><span class="params">(CyclicBarrier cyclicBarrier, String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span> * (<span class="keyword">new</span> Random().nextInt(<span class="number">5</span>)));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"运动员："</span> + name + <span class="string">"is ready"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"运动员："</span> + name + <span class="string">"go。。。。"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当这些线程都达到barrier状态时会执行的内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Cheering</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"啦啦队："</span> + <span class="string">"加油加油加油！！！！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">3</span>, <span class="keyword">new</span> Cheering());</span><br><span class="line">        Executor executor = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        Runner runnerA = <span class="keyword">new</span> Runner(cyclicBarrier, <span class="string">"张三"</span>);</span><br><span class="line">        Runner runnerB = <span class="keyword">new</span> Runner(cyclicBarrier, <span class="string">"李四"</span>);</span><br><span class="line">        Runner runnerC = <span class="keyword">new</span> Runner(cyclicBarrier, <span class="string">"王麻子"</span>);</span><br><span class="line">        executor.execute(runnerA);</span><br><span class="line">        executor.execute(runnerB);</span><br><span class="line">        executor.execute(runnerC);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：<br><img alt="啦啦队" data-src="https://img-blog.csdnimg.cn/2018111112011855.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTczODk5,size_16,color_FFFFFF,t_70" class="lozad"></p><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>Semaphore翻译成字面意思为 信号量，Semaphore可以控同时访问的线程个数，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。<br>它提供了2个构造器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>参数permits表示许可数目，即同时可以允许多少线程进行访问，参数fair表示是否是公平的，等待时间越久的越先获取许可<br>下面说一下Semaphore类中比较重要的几个方法，首先是acquire()、release()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取一个许可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;&#125;</span><br><span class="line"><span class="comment">//获取permits个许可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> permits)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;&#125;</span><br><span class="line"><span class="comment">//释放一个许可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">//释放permits个许可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>以上4个方法都会被阻塞，如果想立即得到执行结果，可以使用下面几个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尝试获取一个许可，若获取成功，则立即返回true，若获取失败，则立即返回false</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">()</span> </span>&#123; &#125;;</span><br><span class="line"><span class="comment">//尝试获取一个许可，若在指定的时间内获取成功，则立即返回true，否则则立即返回false</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123; &#125;;</span><br><span class="line"> <span class="comment">//尝试获取permits个许可，若获取成功，则立即返回true，若获取失败，则立即返回false</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123; &#125;;</span><br><span class="line"><span class="comment">//尝试获取permits个许可，若在指定的时间内获取成功，则立即返回true，否则则立即返回false</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123; &#125;;</span><br></pre></td></tr></table></figure><p>另外还可以通过availablePermits()方法得到可用的许可数目。</p><p>假若一个工厂有5台机器，但是有8个工人，一台机器同时只能被一个工人使用，只有使用完了，其他工人才能继续使用。那么我们就可以通过Semaphore来实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">8</span>;            <span class="comment">//工人数</span></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">5</span>); <span class="comment">//机器数目</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">            <span class="keyword">new</span> Worker(i,semaphore).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">        <span class="keyword">private</span> Semaphore semaphore;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(<span class="keyword">int</span> num,Semaphore semaphore)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.num = num;</span><br><span class="line">            <span class="keyword">this</span>.semaphore = semaphore;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                semaphore.acquire();</span><br><span class="line">                System.out.println(<span class="string">"工人："</span>+<span class="keyword">this</span>.num+<span class="string">" 占用一个机器在生产..."</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                System.out.println(<span class="string">"工人："</span>+<span class="keyword">this</span>.num+<span class="string">"生产完成，释放出机器"</span>);</span><br><span class="line">                semaphore.release();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：<br><img alt="工人" data-src="https://img-blog.csdnimg.cn/20181111123059876.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTczODk5,size_16,color_FFFFFF,t_70" class="lozad"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 线程安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之单例模式</title>
      <link href="/2019/09/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/09/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式之单例模式"><a href="#设计模式之单例模式" class="headerlink" title="设计模式之单例模式"></a>设计模式之单例模式</h1><blockquote><p>单例模式是指整个应用中某个类只有一个实例出现，并且提供一个全局访问点。</p></blockquote><h2 id="饿汉式（简单粗暴）"><a href="#饿汉式（简单粗暴）" class="headerlink" title="饿汉式（简单粗暴）"></a>饿汉式（简单粗暴）</h2><blockquote><p>这种方法语法非常简单，并且也便于阅读，因为单例的实例被声明成 static 和 final 变量了，在第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="comment">//类加载时就初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：</p><p> -增加初始化内存消耗（结合实际考虑，大多数情况下此缺点可忽略）</p><h2 id="懒汉（线程不安全）"><a href="#懒汉（线程不安全）" class="headerlink" title="懒汉（线程不安全）"></a>懒汉（线程不安全）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">         instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="懒汉（线程安全）"><a href="#懒汉（线程安全）" class="headerlink" title="懒汉（线程安全）"></a>懒汉（线程安全）</h2><p>上段代码在单线程环境下不存在问题，但是如果处于并发场景，就需要考虑线程安全，最熟悉莫过于<strong>双检锁</strong>，其要点在于：<br> -volatile能够提供”可见性”，以及保证getInstance返回的是初始化<strong>安全</strong>的实例<br> -在同步之前进行null检查，以尽量避免进入相对昂贵的同步块<br> -直接在 class级别进行同步，保证线程安全的类方法调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//volatile，保证操作可见性和禁止指令重排</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列化会通过反射调用无参数的构造方法创建一个新的对象</span></span><br><span class="line"><span class="comment">     * 避免序列化重新new 对象 需添加此方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/*private Object readResolve() &#123;</span></span><br><span class="line"><span class="comment">        return Singleton.instance;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在这段代码中，争论较多的是volatile修饰静态变量，当Singleton类本身有多个成员变量时，需要保证初始化过程完成后，才能被get到。</p><h3 id="浅说volatile"><a href="#浅说volatile" class="headerlink" title="浅说volatile"></a>浅说volatile</h3><p> 关于volatile的详细说明，可以参考这篇帖子：<a href="https://www.cnblogs.com/dolphin0520/p/3920373.html" target="_blank" rel="noopener">Java并发编程：volatile关键字解析</a></p><blockquote><p>volatile 确保操作是可见性的，每次都是去主内存中读取，还可以避免指令重排（有序性）。看下面这个例子：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;<span class="comment">//①</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;<span class="comment">//②</span></span><br><span class="line"><span class="keyword">int</span> c = a + b;<span class="comment">//③</span></span><br></pre></td></tr></table></figure><p>这段代码看似简单，显然的运行顺序是①②③，但是在JVM中运行，这可不一定。这里提一下<strong>as-if-serial</strong>，as-if-serial是指在执行结果不会改变的情况下，JVM为了提高程序的执行效率会对指令进行重排序（单线程下的<strong>执行结果</strong>不改变）。如果两个操作访问同一个变量，其中一个为写操作，此时这两个操作之间存在数据依赖性。 编译器和处理器不会改变<strong>存在数据依赖性关系的两个操作的执行顺序，即不会重排序</strong>。从上述代码分析：因为③是一定要在①和②之后执行的，但是①和②则就没有依赖了，①和②谁先执行都不影响结果，所以JVM就可能会对它们进行重排序，所以指令的执行顺序可能是：<strong>①②③</strong>或<strong>②①③</strong><br>  讲完上述例子，我们再看上一个<strong>Singleton</strong> 代码。<code>instance = new Singleton();</code>，这段代码并非原子操作，它的执行步骤是：<br>   -分配空间给对象①<br>   -在空间内创建对象②<br>   -将对象赋值给引用instance③</p><blockquote><p>上述过程中，②是依赖于①的，③也是是依赖于①的，所以②在①之后执行，③也在①之后执行，但是③和②不存在依赖性，所以执行顺序可能是：①-&gt;③-&gt;②或①-&gt;②-&gt;③，如果是单线程的程序（真的只有一个线程可以访问到它们），那么如果后续程序使用到了instance，JVM会保证你使用instance的时候是初始化完成的，但是现在在synchronized块之外有其它线程“虎视眈眈”，获取到锁的线程如果按照①-&gt;③-&gt;②的顺序执行，那在执行③的时候会store-write，即将值写回主内存，则其它线程会读到最新的instance值，而现在这个instance指向的是一个不完全的对象，即不安全对象，也不可用，使用这个实例是有危险的，此时构造对象的线程还没有释放锁，其它线程进行第一次检查的时候，null == instance的结果是false，会返回这个对象，造成程序的异常。 </p></blockquote><p>  一说到指令重排序，我们很容易想到volatile关键字，所以如果instance被volatile修饰的话，可以保证这个初始化的有序性。在现代Java中，内存排序模型（JMM）已经非常完善，通过volatile的write或者read，能保证所谓的happen-before，也就是避免常被提到的指令重排。换句话说，构造对象的store指令能够被保证一定在volatile read之前。</p><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><blockquote><p>当然，也有一些人推荐利用内部类持有静态对象的方式实现，其理论依据是对象初始化过程中隐含的初始化锁，这种和显视的双检锁实现都能保证线程安全，不过语法稍显晦涩，未必有特别的优势。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EnumSingleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>枚举单例写法简单，线程安全，可以防止反射调用构造器，可以防止反序列化的时候创建新的对象（实际也是反射），Effective Java》作者推荐使用的方法。</p></blockquote><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>上面是比较学究的考察，实际实践中未必需要如此复杂，比如java.lang.Runtime中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Runtime</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Runtime currentRuntime = <span class="keyword">new</span> Runtime();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Runtime <span class="title">getRuntime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> currentRuntime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Runtime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="单例的优缺点"><a href="#单例的优缺点" class="headerlink" title="单例的优缺点"></a>单例的优缺点</h2><p>优点：<br> -由于单例模式在内存中只有一个是实例，避免了频繁创建对象时的性能开销。<br> -避免对资源的多重占用，单例模式可以在系统设置全局的访问点，优化和共享资源访问问。<br> -单例可以扩展成有固定数量对象的模式，叫做有上限的多例模式。我们可以在设计之初决定该类在系统中有几个实例，提供系统的处理速度。例如，在连接数据库时，可以预先初始化固定数量的连接，然后在需要并发读取读数据库的时候可以提高系统处理速度。</p><p>缺点：<br> -单例模式没有接口，不能抽象，扩展困难<br> -与单一职责原则有冲突（不一定是很糟糕的）。一个类应该只实现一个逻辑，而不关心它是否是单例的，单例模式把“要单例”和业务逻辑融合在一个类中。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 设计原则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之动态代理</title>
      <link href="/2019/09/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
      <url>/2019/09/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式之动态代理"><a href="#设计模式之动态代理" class="headerlink" title="设计模式之动态代理"></a>设计模式之动态代理</h1><blockquote><p>何为代理，代理概念可以解释为:在出发点到目的地之间有一道中间层,意为代理。何为代理模式，为其他对象提供一种代理以控制对这个对象的访问。</p></blockquote><h2 id="三要素"><a href="#三要素" class="headerlink" title="三要素"></a>三要素</h2><p> -Subject抽象主题角色。可以是抽象类，也可以是接口<br> -RealSubject。具体主题角色，也就是被代理角色<br> -Proxy代理主题角色。也叫做为委托类，代理类。它负责对真实主题的调用，把所有抽象主题类定义的方法委托给真实主题角色的实现，并且在真实主题角色处理完毕后前后做预处理和善后工作。</p><h2 id="反例"><a href="#反例" class="headerlink" title="反例"></a>反例</h2><blockquote><p>下面的示例中，以实现一个简单的计算器为例，这个计算可以计算加法和减法，并且将结果进行输出</p></blockquote><p>先定义一个计算器接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>：xiapeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>：计算器接口（Subject抽象主题角色）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2018-10-22 11:06</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>计算器实现类*</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CalculatorImpl</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xiapeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 计算器实现类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018-10-22 11:07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatorImpl</span> <span class="keyword">implements</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c = x + y;</span><br><span class="line">        System.out.println(<span class="string">"add方法结果为："</span> + c);</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c = x - y;</span><br><span class="line">        System.out.println(<span class="string">"sub方法结果为："</span> + c);</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>client类：</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Client</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xiapeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 客户端计算</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018-10-22 11:12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Calculator calculator = <span class="keyword">new</span> CalculatorImpl();</span><br><span class="line">        calculator.add(<span class="number">10</span>, <span class="number">6</span>);</span><br><span class="line">        System.out.println(<span class="string">"--------------------------------------------------------------------"</span>);</span><br><span class="line">        calculator.sub(<span class="number">10</span>, <span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以上做法是不推荐的，如果计算以后新增了一个乘法除法，也需要记录日志，是不是也得在具体实现方法里面加上日志代码呐？接下来介绍使用动态代理来实现该功能</p></blockquote><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>计算器实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CalculatorImpl</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xiapeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 计算器实现类（RealSubject）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018-10-22 11:07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatorImpl</span> <span class="keyword">implements</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c = x + y;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c = x - y;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>日志处理类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LoggingHandler</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xiapeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 日志处理(Proxy代理主题角色)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018-10-22 11:10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggingHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Calculator calculator;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LoggingHandler</span><span class="params">(Calculator calculator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.calculator = calculator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object result = method.invoke(calculator, args);</span><br><span class="line">        System.out.println(method.getName() + <span class="string">"方法结果为："</span> + result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Client</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xiapeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 客户端计算</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018-10-22 11:12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Calculator calculator = <span class="keyword">new</span> CalculatorImpl();</span><br><span class="line">        Calculator proxiedCalculator = (Calculator) Proxy.newProxyInstance(</span><br><span class="line">            calculator.getClass().getClassLoader(),</span><br><span class="line">            calculator.getClass().getInterfaces(),</span><br><span class="line">            <span class="keyword">new</span> LoggingHandler(calculator)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        proxiedCalculator.add(<span class="number">10</span>, <span class="number">6</span>);</span><br><span class="line">        System.out.println(<span class="string">"--------------------------------------------------------------------"</span>);</span><br><span class="line">        proxiedCalculator.sub(<span class="number">10</span>, <span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>相比反例中的代码，这段代码的好处就是如果计算器增加了计算方法，如乘法，除法，记录日志时，不需要耦合到具体实现类，换言之，不需要为加减乘除的每个方法里面增加日志代码，而在Proxy代理主题角色（LoggingHandler.java）进行处理。</p></blockquote><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p> -职责清晰。真实的角色就只是实现业务逻辑，不用关心其他事务。<br> -高扩展性。RealSubject（具体主题实现）无论如何变化，只要他实现了Subject（抽象主题）的接口，都可以被代理。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 设计原则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之建造者（Builder）模式</title>
      <link href="/2019/09/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%BB%BA%E9%80%A0%E8%80%85%EF%BC%88Builder%EF%BC%89%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/09/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%BB%BA%E9%80%A0%E8%80%85%EF%BC%88Builder%EF%BC%89%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式之建造者（Builder）模式"><a href="#设计模式之建造者（Builder）模式" class="headerlink" title="设计模式之建造者（Builder）模式"></a>设计模式之建造者（Builder）模式</h1><blockquote><p>将一个复杂对象的构建与它的表示分离,使得同样的构建过程可以创建不同的表示，Builder模式是一步一步创建一个复杂的对象,它允许用户可以只通过指定复杂对象的类型和内容就可以构建它们.用户不知道内部的具体构建细节。</p></blockquote><h2 id="如何给对象的属性赋值"><a href="#如何给对象的属性赋值" class="headerlink" title="如何给对象的属性赋值"></a>如何给对象的属性赋值</h2><h3 id="构造器赋值"><a href="#构造器赋值" class="headerlink" title="构造器赋值"></a>构造器赋值</h3><p>应用举例：假设我们有一个Person类，结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//必要参数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//可选参数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(id, name, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> id, String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(id, name, age, <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> id, String name, <span class="keyword">int</span> age, String sex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(id, name, age, sex, <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> id, String name, <span class="keyword">int</span> age, String sex, String phone)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(id, name, age, sex, phone, <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> id, String name, <span class="keyword">int</span> age, String sex, String phone, String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(id, name, age, sex, phone, address, <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> id, String name, <span class="keyword">int</span> age, String sex, String phone, String address, String desc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">        <span class="keyword">this</span>.phone = phone;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">        <span class="keyword">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码中，当你想要创建实例的时候，就利用构造器创建对象赋值，如果需要的参数过多的话就如下代码：<br><em>Person person = new Persion(1, “李四”, 20, “男”, “18800000000”, “China”, “测试使用重叠构造器模式”);</em><br>创建使用代码会很难写，并且较难以阅读。</p><h3 id="JavaBean赋值"><a href="#JavaBean赋值" class="headerlink" title="JavaBean赋值"></a>JavaBean赋值</h3><p>接下来，我们利用最熟悉的JavaBean模式进行替代：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//必要参数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//可选参数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(String sex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPhone</span><span class="params">(String phone)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.phone = phone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddress</span><span class="params">(String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDesc</span><span class="params">(String desc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种模式弥补了重叠构造器模式的不足。创建实例很容易，这样产生的代码读起来也很容易：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Person person = <span class="keyword">new</span> Person();</span><br><span class="line">person.setId(<span class="number">1</span>);</span><br><span class="line">person.setName(<span class="string">"李四"</span>);</span><br><span class="line">person.setAge(<span class="number">20</span>);</span><br><span class="line">person.setSex(<span class="string">"男"</span>);</span><br><span class="line">person.setPhone(<span class="string">"17255985656"</span>);</span><br><span class="line">person.setAddress(<span class="string">"China"</span>);</span><br><span class="line">person.setDesc(<span class="string">"使用JavaBeans模式"</span>);</span><br></pre></td></tr></table></figure><p>遗憾的是，JavaBeans模式自身有着很重要的缺点。因为构造过程被分到了几个调用中，它并不是原子操作，在构造过程中JavaBean可能处于不一致的状态。类无法仅仅通过检验构造器参数的有效性来保证一致性。</p><h3 id="Builder模式"><a href="#Builder模式" class="headerlink" title="Builder模式"></a>Builder模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">//必要参数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//可选参数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Person</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = builder.id;</span><br><span class="line">        <span class="keyword">this</span>.name = builder.name;</span><br><span class="line">        <span class="keyword">this</span>.age = builder.age;</span><br><span class="line">        <span class="keyword">this</span>.sex = builder.sex;</span><br><span class="line">        <span class="keyword">this</span>.phone = builder.phone;</span><br><span class="line">        <span class="keyword">this</span>.address = builder.address;</span><br><span class="line">        <span class="keyword">this</span>.desc = builder.desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">        <span class="comment">//必要参数</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">        <span class="comment">//可选参数</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">        <span class="keyword">private</span> String sex;</span><br><span class="line">        <span class="keyword">private</span> String phone;</span><br><span class="line">        <span class="keyword">private</span> String address;</span><br><span class="line">        <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">age</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.age = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">sex</span><span class="params">(String val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.sex = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">phone</span><span class="params">(String val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.phone = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">address</span><span class="params">(String val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.address = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">desc</span><span class="params">(String val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.desc = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Person <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是客户端代码调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person.Builder(<span class="number">1</span>, <span class="string">"张三"</span>)</span><br><span class="line">            .age(<span class="number">18</span>).sex(<span class="string">"男"</span>).desc(<span class="string">"测试使用builder模式"</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Builder模式提供了良好的封装性：使用建造者模式可以使客户端不必知道产品内部组成的细节，上例中，我们不用关心构建的Person对象的过程，产生的对象就是Person类型。<br>Builder模式可以直观的构建复杂的对象，便于阅读，在很多开源组件中，我们都可以找到它的身影，比如ElasticSearch封装的JavaAPI中，<code>QueryBuilder</code>就是builder模式。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 设计原则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之模板方法模式</title>
      <link href="/2019/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式之模板方法模式"><a href="#设计模式之模板方法模式" class="headerlink" title="设计模式之模板方法模式"></a>设计模式之模板方法模式</h1><blockquote><p>模板方法模式是一种炒鸡简单的设计模式，它基于继承的代码复用，定义一个操作中的算法框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重新定义该算法的某些步骤。<br>我们可以将一些复杂流程的实现步骤封装在一系列基本方法中，在抽象父类中提供一个称之为模板方法的方法来定义这些基本方法的执行次序，而通过其子类来覆盖某些步骤，从而使得相同的算法框架可以有不同的执行结果。</p></blockquote><h2 id="反例"><a href="#反例" class="headerlink" title="反例"></a>反例</h2><blockquote><p>假如leader让你做一个汽车的模型，要求只要完成基本功能即可，不考虑扩展性，那你会怎么做呢？我们首先会根据经验设计一个类图<br><img alt="类图" data-src="https://img-blog.csdn.net/20181022141111848?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTczODk5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" class="lozad"></p></blockquote><p>由这个类图可知，非常简单的实现了悍马车，该车有两个型号H1和H2。那现在我们开始实现这两个型号的悍马车，首先我们得把抽象类写好，然后两个不同的模型实现类通过简单的继承就可以实现要求。</p><p>首先看看抽象类<del>HummerModel</del>  的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HummerModel</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xiapeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 抽象汽车动作模板</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018-10-22 14:13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HummerModel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发动</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//停止</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//鸣笛</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">alarm</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//轰鸣</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">engineBoom</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//车总归要跑</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们来实现两个悍马的模型：<br>悍马H1型车<del>HummerH1</del>  ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HummerH1</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xiapeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 悍马H1型车</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018-10-22 14:16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HummerH1</span> <span class="keyword">extends</span> <span class="title">HummerModel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"H1发动"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"H1停止"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">alarm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"H1鸣笛"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">engineBoom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"H1轰鸣"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start();</span><br><span class="line">        <span class="keyword">this</span>.engineBoom();</span><br><span class="line">        <span class="keyword">this</span>.alarm();</span><br><span class="line">        <span class="keyword">this</span>.stop();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>悍马H2型车<del>HummerH2</del>  ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HummerH2</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xiapeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 悍马H2型车</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018-10-22 14:16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HummerH2</span> <span class="keyword">extends</span> <span class="title">HummerModel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"H2发动"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"H2停止"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">alarm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"H2鸣笛"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">engineBoom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"H2轰鸣"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start();</span><br><span class="line">        <span class="keyword">this</span>.engineBoom();</span><br><span class="line">        <span class="keyword">this</span>.alarm();</span><br><span class="line">        <span class="keyword">this</span>.stop();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比H1型车和H2型车，两种汽车的run方法执行的顺序完全相同，所以不应该出现在2个实现类中，应该是所有子类的共性封装。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>将run方法的实现写在抽象类里面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HummerModel</span></span><br><span class="line"><span class="comment"> *  * <span class="doctag">@author</span> xiapeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 抽象汽车启动模板</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018-10-22 14:13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HummerModel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发动</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//停止</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//鸣笛</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">alarm</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//轰鸣</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">engineBoom</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//车总归要跑</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start();</span><br><span class="line">        <span class="keyword">this</span>.engineBoom();</span><br><span class="line">        <span class="keyword">this</span>.alarm();</span><br><span class="line">        <span class="keyword">this</span>.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后两个悍马的模型分别继承HummerModel，这样两个实现类就不用实现run方法了，可以直接拿来用，这就是模板方法模式。为了防止基类方法被<strong>恶意重写</strong>，一般模板方法都得加上<strong>final</strong>关键字</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>封装不变部分，扩展可变部分</li><li>提取公共代码，便于维护</li><li>行为由父类定义，子类负责实现</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>模板方法模式颠倒了我们平常的设计习惯：抽象类负责声明最抽象、最一般的事物属性和方法，实现类实现具体的事物属性和方法，在复杂的项目中可能会带来代码阅读的难度。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 设计原则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之适配器</title>
      <link href="/2019/09/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8/"/>
      <url>/2019/09/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式之适配器"><a href="#设计模式之适配器" class="headerlink" title="设计模式之适配器"></a>设计模式之适配器</h1><blockquote><p>适配器就是一种适配中间件，它存在于不匹配的二者之间，用于连接二者，将不匹配变得匹配，简单点理解就是平常所见的转接头，转换器之类的存在。即定义一个包装类，用于包装不兼容接口的对象</p></blockquote><p>本文讨论适配器模式。适配器模式是23中设计模式之一，它的主要作用是在新接口和老接口之间进行适配。它非常像我们出国旅行时带的电源转换器。为了举这个例子，我还特意去京东上搜了一下电源转换器，确实看到了很多地方的标准不一样。我们国家的电器使用普通的扁平两项或三项插头，而去外国的话，使用的标准就不一样了，比如德国，使用的是德国标准，是两项圆头的插头。如果去德国旅游，那么我们使用的手机充电器插头无法插到德国的插排中去，那就意味着我们无法给手机充电。怎样解决这个问题呢？只要使用一个电源转化器就行了。如下图所示：</p><p><img alt="5b1503d1Ne6255f01.jpg" data-src="http://bed.thunisoft.com:9000/ibed/2019/07/04/cbc4b3fb920b45618c66d07052758976.jpg" class="lozad"></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>先定义一个德标接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DBSocketInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 德国标准：两项圆头的插口供电</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">powerTwoRound</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>德国插座实现德标接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DBSocket</span> <span class="keyword">implements</span> <span class="title">DBSocketInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">powerTwoRound</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"使用两项圆头的插孔供电"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>德国旅馆是一个客户端，它里面有德标的接口，可以使用这个德标接口给手机充电：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hotel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//旅馆中有一个德标的插口</span></span><br><span class="line">    <span class="keyword">private</span> DBSocketInterface dbSocket;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hotel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hotel</span><span class="params">(DBSocketInterface dbSocket)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dbSocket = dbSocket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSocket</span><span class="params">(DBSocketInterface dbSocket)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dbSocket = dbSocket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//旅馆中有一个充电的功能</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">charge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用德标插口充电</span></span><br><span class="line">        dbSocket.powerTwoRound();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化一个德国插座对象， 用一个德标接口引用它</span></span><br><span class="line">        DBSocketInterface dbSoket = <span class="keyword">new</span> DBSocket();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个旅馆对象</span></span><br><span class="line">        Hotel hotel = <span class="keyword">new</span> Hotel(dbSoket);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在旅馆中给手机充电</span></span><br><span class="line">        hotel.charge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序，打印出以下结果： <code>使用两项圆头的插孔供电</code></p><p>现在我去德国旅游，带去的三项扁头的手机充电器。如果没有带电源适配器，我是不能充电的，因为不可能为了我一个旅客而为我更改墙上的插座，更不可能为我专门盖一座使用中国国标插座的宾馆。因为人家德国人一直这么使用，并且用的挺好，俗话说入乡随俗，我就要自己想办法来解决问题。对应到我们的代码中，也就是说，上面的Hotel类，DBSocket类，DBSocketInterface接口都是不可变的（由德国的客户提供），如果我想使用这一套API，那么只能自己解决。</p><p>下面是国标接口和中国插座的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GBSocketInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 中国标准：三项扁头插口供电</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">powerThreeFlat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GBSocket</span> <span class="keyword">implements</span> <span class="title">GBSocketInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">powerThreeFlat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"使用三项扁头插孔供电"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以认为这两个东西是我带到德国去的，目前他们还不能使用，因为接口不一样。那么我必须创建一个适配器，这个适配器必须满足以下条件：</p><ul><li>必须符合德国标准的接口，否则的话还是没办法插到德国插座中；</li><li>在调用上面实现的德标接口进行充电时，提供一种机制，将这个调用转到对国标接口的调用 。</li></ul><p>这就要求：<br>1 适配器必须实现原有的旧的接口<br>2 适配器对象中持有对新接口的引用，当调用旧接口时，将这个调用委托给实现新接口的对象来处理，也就是在适配器对象中组合一个新接口。</p><p>下面给出适配器类的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketAdapter</span> <span class="keyword">implements</span> <span class="title">DBSocketInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//组合新接口</span></span><br><span class="line">    <span class="keyword">private</span> GBSocketInterface gbSocket;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在创建适配器对象时，必须传入一个新街口的实现类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> gbSocket</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SocketAdapter</span><span class="params">(GBSocketInterface gbSocket)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.gbSocket = gbSocket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">powerTwoRound</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        gbSocket.powerThreeFlat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAdapter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//我去德国旅游，带去的充电器是国标的（可以将这里的GBSocket看成是充电器）</span></span><br><span class="line">        GBSocketInterface gbSocket = <span class="keyword">new</span> GBSocket();</span><br><span class="line">        <span class="comment">//来到德国后， 找到一家德国宾馆住下 (这个宾馆还是上面代码中的宾馆，使用的依然是德国标准的插口)</span></span><br><span class="line">        Hotel hotel = <span class="keyword">new</span> Hotel();</span><br><span class="line">        <span class="comment">//由于没法充电，我拿出随身带去的适配器，并且将我带来的充电器插在适配器的上端插孔中。这个上端插孔是符合国标的，我的充电器完全可以插进去。</span></span><br><span class="line">        SocketAdapter socketAdapter = <span class="keyword">new</span> SocketAdapter(gbSocket);</span><br><span class="line">        <span class="comment">//再将适配器的下端插入宾馆里的插座上</span></span><br><span class="line">        hotel.setSocket(socketAdapter);</span><br><span class="line">        <span class="comment">//可以在宾馆中使用适配器进行充电了</span></span><br><span class="line">        hotel.charge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上面的程序，打印出以下结果：<code>使用三项扁头插孔供电</code>.</p><p>这说明适配器起作用了，上一个实例中打印的是：使用两项圆头的插孔供电。 现在可以使用三项扁头插孔供电了。我们并没有改变宾馆中的德标插口，提供了一个适配器就能使用国标的插口充电。这就是适配器模式的魅力：不改变原有接口，却还能使用新接口的功能。</p><p>适配器模式的三个特点：</p><ul><li>适配器对象实现原有接口</li><li>适配器对象组合一个实现新接口的对象（这个对象也可以不实现一个接口，只是一个单纯的对象）</li><li>对适配器原有接口方法的调用被委托给新接口的实例的特定方法</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 设计原则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之策略模式</title>
      <link href="/2019/09/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/09/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式之策略模式"><a href="#设计模式之策略模式" class="headerlink" title="设计模式之策略模式"></a>设计模式之策略模式</h1><blockquote><p>策略模式（Strategy Pattern）是一种简单常用的设计模式，也叫做政策模式（Policy Pattern），定义一组算法，将每个算法封装起来，并且使他们相互转换。</p></blockquote><h2 id="结构组成"><a href="#结构组成" class="headerlink" title="结构组成"></a>结构组成</h2><ul><li><p>Context封装角色</p><blockquote><p>它也叫做上下文角色，起承上启下的封装作用，屏蔽高层模块对策略，算法的直接访问，封装可能存在的变化。</p></blockquote></li><li><p>Strategy抽象策略角色</p></li></ul><blockquote><p>策略、算法的抽象，通常为接口，定义每个策略或算法必有的方法和属性。<br>-具体策略(ConcreteStrategy)角色<br>实现抽象策略中的具体操作，该类含有具体的算法。<br><img alt="策略模式实例结构" data-src="https://img-blog.csdn.net/20181015220302538?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTczODk5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" class="lozad"></p></blockquote><h2 id="示例（改编自网红代码）"><a href="#示例（改编自网红代码）" class="headerlink" title="示例（改编自网红代码）"></a>示例（改编自网红代码）</h2><p>以下代码改编自业界盛传的某超级大厂的网红代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VIPCenter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * user共同属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">BaseUser</span> </span>&#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 穷逼user，送的那种</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">SlumDogVIP</span> <span class="keyword">extends</span> <span class="title">BaseUser</span> </span>&#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 正儿八经买vip的user</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">RealVIP</span> <span class="keyword">extends</span> <span class="title">BaseUser</span> </span>&#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实际业务处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serviceVIP</span><span class="params">(BaseUser user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (user <span class="keyword">instanceof</span> SlumDogVIP) &#123;</span><br><span class="line">            <span class="comment">//穷逼VIP，活动送的那种</span></span><br><span class="line">            System.out.println(<span class="string">"穷逼"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//正儿八经的VIP</span></span><br><span class="line">            System.out.println(<span class="string">"不穷"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对于这段代码，业务逻辑集中在一起，当出现新的用户类型时， 比如，增加一个SuperVIP用户类型，这就需要直接去修改服务方法代码实现（在serviceVIP方法里面在加else if），违反了开关原则（Open-Close）（对新增开放，对修改关闭）。这可能会意外影响不相关的某个用户类型逻辑。</p></blockquote><h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VIPCenterImprove</span> </span>&#123;</span><br><span class="line">    <span class="comment">//抽象策略</span></span><br><span class="line">    <span class="keyword">private</span> ServiceHandler serviceHandler;</span><br><span class="line">    <span class="comment">//构造函数设置具体策略</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VIPCenterImprove</span><span class="params">(ServiceHandler serviceHandler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serviceHandler = serviceHandler;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Context封装角色</span></span><br><span class="line"><span class="comment">     * 封装后的策略方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serviceVIP</span><span class="params">(BaseUser user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serviceHandler.service(user);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * user共同属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseUser</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> desc;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDesc</span><span class="params">(String desc)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.desc = desc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*------------------------------------------------*/</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 穷逼user，送的那种</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SlumDogVIP</span> <span class="keyword">extends</span> <span class="title">BaseUser</span> </span>&#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*------------------------------------------------*/</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 正儿八经买vip的user</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RealVIP</span> <span class="keyword">extends</span> <span class="title">BaseUser</span> </span>&#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*------------------------------------------------*/</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可以为所欲为的VIP</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperVip</span> <span class="keyword">extends</span> <span class="title">BaseUser</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*------------------------------------------------*/</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Strategy抽象策略角色</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">ServiceHandler</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">service</span><span class="params">(BaseUser user)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*------------------------------------------------*/</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 具体策略(ConcreteStrategy)角色</span></span><br><span class="line"><span class="comment">     * 处理穷逼VIP</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SlumDogVIPServiceHandler</span> <span class="keyword">implements</span> <span class="title">ServiceHandler</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(BaseUser user)</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"该用户是："</span> + user.getDesc());</span><br><span class="line">            System.out.println(<span class="string">"穷逼"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*------------------------------------------------*/</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 具体策略(ConcreteStrategy)角色</span></span><br><span class="line"><span class="comment">     * 处理正常的VIP</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RealVIPServiceHandler</span> <span class="keyword">implements</span> <span class="title">ServiceHandler</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(BaseUser user)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"该用户是："</span> + user.getDesc());</span><br><span class="line">            System.out.println(<span class="string">"正常人"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*------------------------------------------------*/</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 具体策略(ConcreteStrategy)角色</span></span><br><span class="line"><span class="comment">     * 处理可以为所欲为的VIP</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperVipServiceHandler</span> <span class="keyword">implements</span> <span class="title">ServiceHandler</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(BaseUser user)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"该用户是："</span> + user.getDesc());</span><br><span class="line">            System.out.println(<span class="string">"可以为所欲为的VIP"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//声明一个具体的策略</span></span><br><span class="line">        ServiceHandler serviceHandler1 = <span class="keyword">new</span> SlumDogVIPServiceHandler();</span><br><span class="line">        BaseUser user1 = <span class="keyword">new</span> SlumDogVIP();</span><br><span class="line">        user1.setDesc(<span class="string">"穷逼"</span>);</span><br><span class="line">        <span class="comment">//声明一个上下文对象</span></span><br><span class="line">        VIPCenterImprove vipCenter1 = <span class="keyword">new</span> VIPCenterImprove(serviceHandler1);</span><br><span class="line">        <span class="comment">//执行封装后的方法</span></span><br><span class="line">        vipCenter1.serviceVIP(user1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二种策略</span></span><br><span class="line">        serviceHandler1 = <span class="keyword">new</span> RealVIPServiceHandler();</span><br><span class="line">        user1 = <span class="keyword">new</span> RealVIP();</span><br><span class="line">        user1.setDesc(<span class="string">"正常"</span>);</span><br><span class="line">        <span class="comment">//只需“注入”策略实现类（RealVIPServiceHandler）</span></span><br><span class="line">        vipCenter1 = <span class="keyword">new</span> VIPCenterImprove(serviceHandler1);</span><br><span class="line">        vipCenter1.serviceVIP(user1);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//第三种策略</span></span><br><span class="line">        <span class="comment">/*serviceHandler1 = new SuperVipServiceHandler();</span></span><br><span class="line"><span class="comment">        user1 = new SuperVip();</span></span><br><span class="line"><span class="comment">        user1.setDesc("富豪");</span></span><br><span class="line"><span class="comment">        vipCenter1 = new VIPCenterImprove(serviceHandler1);</span></span><br><span class="line"><span class="comment">        vipCenter1.serviceVIP(user1);*/</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面的示例，将不同的对象分类的服务方法进行抽象，把业务逻辑的紧耦合关系拆开，实现代码隔离方便扩展。如果以后再出现新的用户类型，只需要重新实现一个策略接口ServiceHandler即可，然后将其注入到VIPCenterImprove（Context），这样比直接在serviceVIP方法里面加else if 优雅！</p></blockquote><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>优点</p><ul><li>算法自由切换，只需要将具体的实现类“注入”到Context中即可</li><li>避免多重条件判断</li><li>扩展性良好</li></ul><p>缺点：</p><ul><li>策略类数量增多</li><li>所有的策略类必须都需要对外暴露。</li></ul><p>使用场景：</p><ul><li>多个类只有在算法或行为上的不同</li><li>算法需要自由切换</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 设计原则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象六大设计原则</title>
      <link href="/2019/05/16/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
      <url>/2019/05/16/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象六大设计原则"><a href="#面向对象六大设计原则" class="headerlink" title="面向对象六大设计原则"></a>面向对象六大设计原则</h1><h2 id="单一职责（Single-Responsibility-Principle）"><a href="#单一职责（Single-Responsibility-Principle）" class="headerlink" title="单一职责（Single Responsibility Principle）"></a>单一职责（Single Responsibility Principle）</h2><blockquote><p>引起类变化的原因只有一个，即一个类就负责一件事情</p></blockquote><p>单一职责要求定义一个类（不仅仅是类，大到模块，小到方法）时，功能要尽可能的简单，定义的越复杂，它能被可重用的可能性就越小。</p><p>比如，常见的管理系统中，要在页面上展示一个列表数据，类结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserApi</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取数据库连接.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> driverClass driverClass</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> user user</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> password password</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> connect</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Connection <span class="title">getConnection</span><span class="params">(String url, String driverClass, String user, String password)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据查询条件查询用户.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> condition 查询条件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回符合条件的用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;T&gt; <span class="title">listUsers</span><span class="params">(T condition)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对查询到的用户进行额外处理.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list 用户集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 最终前台展示数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;T&gt; <span class="title">handleData</span><span class="params">(List list)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上类中，UserApi就承担的职责过多，既要获取连接，又要从数据库获取数据，还要在拿到数据之后做一些处理操作，这个类太“累”了。此时，如果按照 <code>数据如何来</code> 来重新划分职责：可以将UserApi这个类拆分为三类：</p><ul><li>DataSource：含有getConnection方法，专门获取用于数据库连接。</li><li>UserDao：含有listUsers方法，专门用于从数据库获取数据。</li><li>UserService：含有handleData方法，目的在于获取到数据库的数据后，进一步对数据进行业务处理。</li></ul><p>上面这几种拆法，就是我们开发中常用的分层思想，将系统大概分为 dao、service、controller三层，这也是单一职责这一原则的体现。</p><p>上面是按 <code>数据如何来</code> 进行职责划分，所以比较关注数据的周期历程，从哪儿来，经过了什么。如果再将职责放大一点，按照 <code>处理数据</code> 来划分，那么就不会关注数据怎么来的了，只要有数据来就行了，重点应该就在怎么处理数据了，就会对handleData方法进行开刀。</p><p>当然了，一般在这种情况下我们不会这样去划分职责，这里仅仅是想说明单一职责的 <code>职责</code> 是很难去量化的，我们应该根据实际情况尽可能对类的职责进行细化（<code>接口一定要做到单一职责，细化</code>）。</p><p>这样的思想不仅仅是只适用类，也适用于方法，例如，在 <code>handleData(List list)</code> 方法中，如果需要对 <code>list</code> 这个参数进行校验，那么就要将该方法拆分为 <code>check(list)</code> 和 <code>handleData(list)</code>，因为参数校验这个方法很有可能会被其他方法调用，这样可以提高复用性。</p><p>单一职责原则能够 降低类的复杂性，提高可读性和可维护性，但是如果对职责量化适度，就会导致类暴增。</p><h2 id="里氏替换原则（Liskov-Substitution-principle）"><a href="#里氏替换原则（Liskov-Substitution-principle）" class="headerlink" title="里氏替换原则（Liskov Substitution principle）"></a>里氏替换原则（Liskov Substitution principle）</h2><blockquote><p>所有引用基类的地方必须能透明地使用其子类的对象</p></blockquote><p>简而言之，在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立。</p><p>举个栗子：基类——人，有个方法——生娃。子类可能是，亚洲人，非洲人，欧洲人，然后我让他们生娃，他们都能生出娃，而不是别的小动物或者无机物，这就满足了里氏替换原则(LSP)。举个不满足的加深理解：基类——人，有个方法——生娃。子类有超人，机器人，蜘蛛人。看似都具有人的基本特征，但是其中机器人让他生娃，是无法做到的，所以不满足里氏替换，所以机器人不能作为人的基类去定义。</p><p>父类：人，人都可以生娃，子类可以是亚洲人、欧洲人、非洲人，因为他们都能生娃，这些子类满足LSP，但子类不能是机器人，因为机器人不能生娃（至少现在是不能生的），所以机器人不能继承人，不满足LSP。</p><p>LSP原则还有个要求就是</p><blockquote><p>子类的输入参数宽于或等于父类的输入参数</p></blockquote><p>来个例子（参照秦小波《设计模式之禅》）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection <span class="title">doSomeThing</span><span class="params">(HashMap map)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"父类被执行。。。"</span>);</span><br><span class="line">        <span class="keyword">return</span> map.values();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Father father = <span class="keyword">new</span> Father();</span><br><span class="line">        father.doSomeThing(<span class="keyword">new</span> HashMap());</span><br><span class="line"></span><br><span class="line">        Son son = <span class="keyword">new</span> Son();</span><br><span class="line">        son.doSomeThing(<span class="keyword">new</span> HashMap());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载，放大输入参数类型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection <span class="title">doSomeThing</span><span class="params">(Map map)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"子类被执行。。。"</span>);</span><br><span class="line">        <span class="keyword">return</span> map.values();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```子类被执行。。。</span><br></pre></td></tr></table></figure><p>如果将父类和子类的入参类型进行对换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection <span class="title">doSomeThing</span><span class="params">(Map map)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"父类被执行。。。"</span>);</span><br><span class="line">        <span class="keyword">return</span> map.values();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Father father = <span class="keyword">new</span> Father();</span><br><span class="line">        father.doSomeThing(<span class="keyword">new</span> HashMap());</span><br><span class="line"></span><br><span class="line">        Son son = <span class="keyword">new</span> Son();</span><br><span class="line">        son.doSomeThing(<span class="keyword">new</span> HashMap());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载，缩小输入参数类型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection <span class="title">doSomeThing</span><span class="params">(HashMap map)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"子类被执行。。。"</span>);</span><br><span class="line">        <span class="keyword">return</span> map.values();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```子类被执行。。。</span><br></pre></td></tr></table></figure><p>子类的方法被执行了，可能会导致系统逻辑混乱，所以<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">里氏替换原则可以增强程序的健壮性、重用性、可扩展性。</span><br><span class="line"></span><br><span class="line">## 依赖倒置原则（Dependence Inversion Principle）</span><br><span class="line"></span><br><span class="line">&gt; High level modules should not depend upon low level modules.Both should depend upon bstractions.</span><br><span class="line">Abstractions should not depend on details. Details should depend on abstractions.</span><br><span class="line"></span><br><span class="line">简而言之，包含了以下含义：</span><br><span class="line"></span><br><span class="line">- 高层模块不应该依赖低层模块，两者都应该依赖其抽象。</span><br><span class="line">- 抽象不应该依赖细节。</span><br><span class="line">- 细节应该依赖抽象。</span><br><span class="line"></span><br><span class="line">先来个反面教材：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public class DipClient &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Driver driver = new Driver();</span><br><span class="line">        Geely geely = new Geely();</span><br><span class="line">        driver.drive(geely);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Driver &#123;</span><br><span class="line"></span><br><span class="line">        public void drive(Geely geely) &#123;</span><br><span class="line">            geely.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Geely &#123;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;吉利汽车跑起来了。。。&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>很明显，这样的设计是不符合DIP原则的，如果突然有一天换车了，把吉利换成比亚迪，那岂不是没办法开了。Driver作为高层模块，依赖了低层模块的汽车，不同的汽车类对Driver都有影响,这样是不符合逻辑的。</p><p>做出以下修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DipClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ICar car = <span class="keyword">new</span> Geely();</span><br><span class="line">        <span class="comment">//驾驶员开吉利汽车</span></span><br><span class="line">        Driver driver = <span class="keyword">new</span> Driver();</span><br><span class="line">        driver.drive(car);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//驾驶员开比亚迪</span></span><br><span class="line">        driver.drive(<span class="keyword">new</span> BYD());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">ICar</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Geely</span> <span class="keyword">implements</span> <span class="title">ICar</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"吉利汽车跑起来了。。。"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BYD</span> <span class="keyword">implements</span> <span class="title">ICar</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"比亚迪跑起来了。。。build your dreams"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">(ICar iCar)</span> </span>&#123;</span><br><span class="line">            iCar.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改之后的结构，Driver由原来的依赖具体汽车（Geely），变成了依赖ICar抽象，并且Geely也依赖ICar抽象，发生了“倒置”；驾驶员只依赖汽车，不管它是什么汽车，。当然了还可以进一步抽象，Driver可以有很多种，A驾、B驾等等，开的车都不一样，所以就可以对ICar和Driver进行进一步抽象。</p><p>依赖倒置原则的本质就是通过抽象（接口或抽象类）使各个类或模块的实现彼此独立，不互相影响，实现模块间的松耦合，提高扩展性。其核心思想就是OOP（面向接口编程）。</p><h2 id="接口隔离原则（Interface-Segregation-Principle）"><a href="#接口隔离原则（Interface-Segregation-Principle）" class="headerlink" title="接口隔离原则（Interface Segregation Principle）"></a>接口隔离原则（Interface Segregation Principle）</h2><blockquote><p>Clients should not be forced to depend upon interfaces that they don’t use.客户端不应该依赖它不需用的接口。</p><p>The dependency of one class to another one should depend on the smallest possible interface。一个类对另外一个类的依赖性应当是建立在最小的接口上的。</p></blockquote><p>以上对ISP的两种定义，可简要概括为：</p><blockquote><blockquote><p>接口应该尽量细化。这可能会和单一职责有些相似，单一职责和接口隔离的观察角度不同，单一职责要求类的 <code>职责</code> 应该尽量单一，是从业务逻辑区分的。</p></blockquote></blockquote><p>什么是码帝（专家）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Expert</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 精通java.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">proficientjava</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 精通JavaScript.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">proficientJs</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 精通c#.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">proficientCSharp</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个case，定义了要成为一个编程专家所具备的特点。这么定义的问题是，我如果是个专家，实现了这个接口，那么必须实现这个接口的所有方法，换言之，我是编程专家，那么必须要 精通 Java、JavaScript、C#，然而，术业有专攻，虽然计算机语言有很多相同的地方，但是要是同时精通三门语言，还是比较困难的。一般情况下，只要精通一种，就已经是高手了。</p><p>显然，这么定义高手是不符合现实要求的，根据接口隔离原则，应该讲专家的特点拆分：Javaexpert、JsExpert、CSharpExpert，只要实现了其中一个接口，就已经是专家了。当然了会有同时精通java、js、C#的资深专家，那么只需同时实现这三个接口即可。</p><p>接口隔离原则需注意：</p><ul><li>接口尽量细、小</li><li>接口要高内聚（提高处理能力的同时减少对外的交互）（少喊口号多做事）。</li><li>设计接口粒度的时候要有限度（根据自身系统情况设计）</li></ul><h2 id="迪米特法则Law-of-Demeter-Least-Knowledge-Principle）"><a href="#迪米特法则Law-of-Demeter-Least-Knowledge-Principle）" class="headerlink" title="迪米特法则Law of Demeter | Least Knowledge Principle）"></a>迪米特法则Law of Demeter | Least Knowledge Principle）</h2><blockquote><p>也叫 <code>最少知识原则（Least Knowledge Principle）</code>，一个对象应该对其它对象有最少的了解，简单讲，一个类应该对自己需要耦合或调用的类知道得最少。即：Only talk to your immediate friends.(只与直接的朋友通信)</p></blockquote><p>以老师叫学习委员收全班同学的课后作业为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LodClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Teacher teacher = <span class="keyword">new</span> Teacher();</span><br><span class="line">        teacher.command(<span class="keyword">new</span> Commissary());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 老师类.</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">command</span><span class="params">(Commissary commissary)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 模拟生成班上同学.</span></span><br><span class="line">            List&lt;Student&gt; students = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">                students.add(<span class="keyword">new</span> Student());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//学习委员收作业</span></span><br><span class="line">            commissary.collectWork(students);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 学习委员.</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Commissary</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">collectWork</span><span class="params">(List&lt;Student&gt; student)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"学习委员一共强制收了："</span> + student.size() + <span class="string">"份作业！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//学生</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先确定一下Teacher类有几个朋友类——出现在成员变量、方法的输入输出参数中的类称为成员朋友类，出现在方法体内部的类不属于朋友类。而Student这个类出现在<code>command</code>方法体内，因此不属于Teacher的朋友类，但是它却与<code>command</code>有了交流，和陌生人进行了交流，违反了<code>只与直接的朋友通信</code>这一原则，也就是违反了LOD原则。</p><p>经过简单修改后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LodClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 模拟生成班上同学.</span></span><br><span class="line">        List&lt;Student&gt; students = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">            students.add(<span class="keyword">new</span> Student());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Teacher teacher = <span class="keyword">new</span> Teacher();</span><br><span class="line">        Commissary commissary = <span class="keyword">new</span> Commissary(students);</span><br><span class="line">        <span class="comment">// 老师给学习发布收作业命令.</span></span><br><span class="line">        teacher.command(commissary);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 老师类.</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">command</span><span class="params">(Commissary commissary)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//学习委员收作业</span></span><br><span class="line">            commissary.collectWork();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 学习委员.</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Commissary</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> List&lt;Student&gt; students;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Commissary</span><span class="params">(List&lt;Student&gt; students)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.students = students;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">collectWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"学习委员一共强制收了："</span> + <span class="keyword">this</span>.students.size() + <span class="string">"份作业！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//学生</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改之后的类，Teacher避免和学生产生关系，只与学习委员有关系，降低了系统的耦合。迪米特原则为什么要求对自己需要耦合或调用的类知道得最少？举个例子，你去4S店修车，你关心这个车具体是怎么修的吗？你只需关心你的车能不能修好！车上的零部件那么多，你越想了解就觉得越“类”。</p><h2 id="开闭原则（Open-Closed-Principle）"><a href="#开闭原则（Open-Closed-Principle）" class="headerlink" title="开闭原则（Open Closed Principle）"></a>开闭原则（Open Closed Principle）</h2><blockquote><p>Software entities like classes, modules and functions should be open for extension but closed for modification.（软件实体如类、模块、函数应该对扩展开放，对修改关闭。）</p></blockquote><p>接下来以改编自业界盛传的某超级大厂的网红代码为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VIPCenter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * user共同属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">BaseUser</span> </span>&#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 穷逼user，送的那种</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">SlumDogVIP</span> <span class="keyword">extends</span> <span class="title">BaseUser</span> </span>&#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 正儿八经买vip的user</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">RealVIP</span> <span class="keyword">extends</span> <span class="title">BaseUser</span> </span>&#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实际业务处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serviceVIP</span><span class="params">(BaseUser user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (user <span class="keyword">instanceof</span> SlumDogVIP) &#123;</span><br><span class="line">            <span class="comment">//穷逼VIP，活动送的那种</span></span><br><span class="line">            System.out.println(<span class="string">"穷逼"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//正儿八经的VIP</span></span><br><span class="line">            System.out.println(<span class="string">"不穷"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于这段代码，业务逻辑集中在一起，当出现新的用户类型时， 比如，增加一个SuperVIP用户类型，这就需要直接去修改服务方法代码实现（在serviceVIP方法里面在加else if），违反了开关原则（Open-Close）（对新增开放，对修改关闭）。这可能会意外影响不相关的某个用户类型逻辑。</p><p>对业务处理类进行抽象改进：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VIPCenter</span> </span>&#123;</span><br><span class="line">    <span class="comment">//抽象策略</span></span><br><span class="line">    <span class="keyword">private</span> ServiceHandler serviceHandler;</span><br><span class="line">    <span class="comment">//构造函数设置具体策略</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VIPCenter</span><span class="params">(ServiceHandler serviceHandler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serviceHandler = serviceHandler;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Context封装角色</span></span><br><span class="line"><span class="comment">     * 封装后的策略方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serviceVIP</span><span class="params">(BaseUser user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serviceHandler.service(user);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * user共同属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseUser</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> desc;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDesc</span><span class="params">(String desc)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.desc = desc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*------------------------------------------------*/</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 穷逼user，送的那种</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SlumDogVIP</span> <span class="keyword">extends</span> <span class="title">BaseUser</span> </span>&#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*------------------------------------------------*/</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 正儿八经买vip的user</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RealVIP</span> <span class="keyword">extends</span> <span class="title">BaseUser</span> </span>&#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*------------------------------------------------*/</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可以为所欲为的VIP</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperVip</span> <span class="keyword">extends</span> <span class="title">BaseUser</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*------------------------------------------------*/</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Strategy抽象策略角色</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">ServiceHandler</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">service</span><span class="params">(BaseUser user)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*------------------------------------------------*/</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 具体策略(ConcreteStrategy)角色</span></span><br><span class="line"><span class="comment">     * 处理穷逼VIP</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SlumDogVIPServiceHandler</span> <span class="keyword">implements</span> <span class="title">ServiceHandler</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(BaseUser user)</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"该用户是："</span> + user.getDesc());</span><br><span class="line">            System.out.println(<span class="string">"穷逼"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*------------------------------------------------*/</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 具体策略(ConcreteStrategy)角色</span></span><br><span class="line"><span class="comment">     * 处理正常的VIP</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RealVIPServiceHandler</span> <span class="keyword">implements</span> <span class="title">ServiceHandler</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(BaseUser user)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"该用户是："</span> + user.getDesc());</span><br><span class="line">            System.out.println(<span class="string">"正常人"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*------------------------------------------------*/</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 具体策略(ConcreteStrategy)角色</span></span><br><span class="line"><span class="comment">     * 处理可以为所欲为的VIP</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperVipServiceHandler</span> <span class="keyword">implements</span> <span class="title">ServiceHandler</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(BaseUser user)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"该用户是："</span> + user.getDesc());</span><br><span class="line">            System.out.println(<span class="string">"可以为所欲为的VIP"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//声明一个具体的策略</span></span><br><span class="line">        ServiceHandler serviceHandler1 = <span class="keyword">new</span> SlumDogVIPServiceHandler();</span><br><span class="line">        BaseUser user1 = <span class="keyword">new</span> SlumDogVIP();</span><br><span class="line">        user1.setDesc(<span class="string">"穷逼"</span>);</span><br><span class="line">        <span class="comment">//声明一个上下文对象</span></span><br><span class="line">        VIPCenter vipCenter1 = <span class="keyword">new</span> VIPCenter(serviceHandler1);</span><br><span class="line">        <span class="comment">//执行封装后的方法</span></span><br><span class="line">        vipCenter1.serviceVIP(user1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二种策略</span></span><br><span class="line">        serviceHandler1 = <span class="keyword">new</span> RealVIPServiceHandler();</span><br><span class="line">        user1 = <span class="keyword">new</span> RealVIP();</span><br><span class="line">        user1.setDesc(<span class="string">"正常"</span>);</span><br><span class="line">        <span class="comment">//只需“注入”策略实现类（RealVIPServiceHandler）</span></span><br><span class="line">        vipCenter1 = <span class="keyword">new</span> VIPCenter(serviceHandler1);</span><br><span class="line">        vipCenter1.serviceVIP(user1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第三种策略</span></span><br><span class="line">        <span class="comment">/*serviceHandler1 = new SuperVipServiceHandler();</span></span><br><span class="line"><span class="comment">        user1 = new SuperVip();</span></span><br><span class="line"><span class="comment">        user1.setDesc("富豪");</span></span><br><span class="line"><span class="comment">        vipCenter1 = new VIPCenterImprove(serviceHandler1);</span></span><br><span class="line"><span class="comment">        vipCenter1.serviceVIP(user1);*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的示例（策略模式），将不同的对象分类的服务方法进行抽象，把业务逻辑的紧耦合关系拆开，实现代码隔离方便扩展。如果以后再出现新的用户类型，只需要重新实现一个策略接口ServiceHandler即可，然后将其注入到VIPCenter，这样比直接在serviceVIP方法里面加else if 优雅！</p><p>开闭原则能屏蔽回归测试的影响（加一个 else if 就得再回归测试一遍功能，万一你 else if 加错了呐），提高了代码的可维护性。</p><h2 id="个人看法"><a href="#个人看法" class="headerlink" title="个人看法"></a>个人看法</h2><p>六大设计原则深深的贯彻了面向对象编程思想，设计原则仅仅是个工具，对我们软件设计是指导作用，而不是决定作用，不可作为一个软件好坏的唯一标准。设计原则必须得结合实际情况，在设计软件时，不能无限地考虑未来的变更情况，否则就会陷入设计的泥潭中不能自拔。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 设计原则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM之双亲委派模型</title>
      <link href="/2018/10/28/JVM%E4%B9%8B%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/"/>
      <url>/2018/10/28/JVM%E4%B9%8B%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM之双亲委派模型"><a href="#JVM之双亲委派模型" class="headerlink" title="JVM之双亲委派模型"></a>JVM之双亲委派模型</h1><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>&nbsp;&nbsp;在类的加载阶段，需要通过一个类的全限定名来获取定义此类的二进制字节流，这<strong>二进制字节流</strong>并没有指明需要从Class文件中获取，也可以通过ZIP包、网络、动态代理方式或者是其它文件数据库等资源类型中获取，完成这个动作的代码块就是类加载器。这一动作是放在Java虚拟机外部去实现的，以便让应用程序自己决定如何获取所需的类。类加载器（ClassLoader）是Java语言的一项创新，也是Java流行的一个重要原因。</p><h3 id="唯一性"><a href="#唯一性" class="headerlink" title="唯一性"></a>唯一性</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;类加载器虽然只用于实现类的加载动作，但是对于任意一个类，都需要由加载它的类加载器和这个类本身共同确立其在Java虚拟机中的唯一性。通俗的说，JVM中两个类是否“相等”，首先就必须是同一个类加载器加载的，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要类加载器不同，那么这两个类必定是不相等的。<br>&nbsp;&nbsp;&nbsp;&nbsp;这里的“相等”，包括代表类的Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法的返回结果，也包括使用instanceof关键字做对象所属关系判定等情况。<br>&nbsp;&nbsp;&nbsp;&nbsp;以下代码说明了不同的类加载器对instanceof关键字运算的结果的影响。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">        ClassLoader classLoader = <span class="keyword">new</span> ClassLoader() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">                String fileName = name.substring(name.lastIndexOf(<span class="string">"."</span>) + <span class="number">1</span>) + <span class="string">".class"</span>;</span><br><span class="line">                InputStream inputStream = getClass().getResourceAsStream(fileName);</span><br><span class="line">                <span class="keyword">if</span> (inputStream == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">byte</span>[] bytes;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[inputStream.available()];</span><br><span class="line">                    inputStream.read(bytes);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> defineClass(name,bytes,<span class="number">0</span>,bytes.length);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 使用ClassLoaderTest的类加载器加载本类</span></span><br><span class="line">        <span class="comment">/*Object obj1 = ClassLoaderTest.class.getClassLoader().loadClass("factory.ClassLoaderTest").newInstance();</span></span><br><span class="line"><span class="comment">        System.out.println(obj1.getClass());</span></span><br><span class="line"><span class="comment">        System.out.println(obj1 instanceof factory.ClassLoaderTest);*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用自定义类加载器加载本类</span></span><br><span class="line">        Object object = classLoader.loadClass(<span class="string">"factory.ClassLoaderTest"</span>).newInstance();</span><br><span class="line">        System.out.println(object.getClass());</span><br><span class="line">        System.out.println(object <span class="keyword">instanceof</span> factory.ClassLoaderTest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;运行结果为：<br><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;class factory.ClassLoaderTest<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;true<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;class factory.ClassLoaderTest<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;false</strong></p><blockquote><p>上述例子中，虚拟机中存在了两个<strong>ClassLoaderTest</strong>，就是因为所使用的类加载器不同，一个是由系统应用程序类加载器加载的，另外一个是由我们自定义的类加载器加载的，虽然都来自同一个Class文件，但依然是两个独立的类，做对象所属类型检查时结果自然为false。</p></blockquote><h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>&nbsp;&nbsp;从Java虚拟机的角度来说，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用C++语言实现（HotSpot虚拟机中），是虚拟机自身的一部分；另一种就是所有其他的类加载器，这些类加载器都有Java语言实现，独立于虚拟机外部，并且全部继承自java.lang.ClassLoader。<br>&nbsp;&nbsp;从开发者的角度，类加载器可以细分为：</p><ul><li>启动类加载器（Bootstrap ClassLoader）<br>&nbsp;&nbsp;&nbsp;&nbsp;负责将放在<java_home>\lib目录中的，或被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如rt.jar）类库加载到虚拟机内存中。<br>启动类加载器无法被Java程序直接引用，用户再编写自定义加载器时，如果需要把加载器请求委派给启动类加载器，那么直接使用null代替即可。</java_home></li><li>扩展类加载器（Extension ClassLoader）<br>&nbsp;&nbsp;&nbsp;&nbsp;由sun.misc.Launcher$ExtClassLoader实现，它负责加载在<java_home>\lib\ext目录中的，或被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。</java_home></li><li>应用程序类加载器（Application ClassLoader）<br>&nbsp;&nbsp;&nbsp;&nbsp;由sun.misc.Launcher$App-ClassLoader实现。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值。所以一般也称它为系统类加载器。 它负责加载用户路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li></ul><p>&nbsp;&nbsp;还有自定义的类加载器，它们之间的层次关系被称为类加载器的双亲委派模型。该模型要求除了顶层的启动类加载器外，其余的类加载器都应该有自己的父类加载器，而这种父子关系一般通过组合（Composition）关系来实现，而不是通过继承（Inheritance）。</p><p><img alt="类加载器双亲委派模型" data-src="https://img-blog.csdnimg.cn/20181028233129991.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTczODk5,size_27,color_FFFFFF,t_70" class="lozad"></p><h3 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上。 因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。<br>&nbsp;&nbsp;&nbsp;&nbsp;使用双亲委派模型的好处在于Java类随着它的类加载器一起具备了一种带有<strong>优先级的层次关系</strong>。例如类java.lang.Object，它存在在rt.jar中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的Bootstrap ClassLoader进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果没有双亲委派模型而是由各个类加载器自行加载的话，如果用户编写了一个java.lang.Object的同名类并放在ClassPath中，那系统中将会出现多个不同的Object类，程序将混乱。因此，如果开发者尝试编写一个与rt.jar类库中重名的Java类，可以正常编译，但是永远无法被加载运行。</p><h3 id="双亲委派模型实现"><a href="#双亲委派模型实现" class="headerlink" title="双亲委派模型实现"></a>双亲委派模型实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// ①首先，检查请求的类是否已经被加载过了</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);<span class="comment">//②委派父类加载</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        c = findBootstrapClassOrNull(name);<span class="comment">//使用启动类加载器</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// 如果父类加载器抛出异常</span></span><br><span class="line">                    <span class="comment">// 说明父类加载器无法完成加载请求</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// ④在父类加载器无法加载的时候</span></span><br><span class="line">                    <span class="comment">// 再调用本身的findClass方法来进行类加载</span></span><br><span class="line">                    c = findClass(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;在java.lang.ClassLoader的loadClass()方法中，先检查是否已经被加载过，若没有加载则调用父类加载器的loadClass()方法，若父加载器为空则默认使用启动类加载器作为父加载器。如果父加载失败，则抛出ClassNotFoundException异常后，再调用自己的findClass()方法进行加载。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
            <tag> 双亲委派 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM之垃圾回收</title>
      <link href="/2018/10/27/JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
      <url>/2018/10/27/JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM之垃圾回收"><a href="#JVM之垃圾回收" class="headerlink" title="JVM之垃圾回收"></a>JVM之垃圾回收</h1><blockquote><p>Java 语言的一大特点就是可以进行自动垃圾回收处理，而无需开发人员过于关注系统资源，例如内存资源的释放情况。自动垃圾收集虽然大大减轻了开发人员的工作量，但是也增加了软件系统的负担。拥有垃圾收集器可以说是 Java 语言与 C++语言的一项显著区别。在 C++语言中，程序员必须小心谨慎地处理每一项内存分配，且内存使用完后必须手工释放曾经占用的内存空间。当内存释放不够完全时，即存在分配但永不释放的内存块，就会引起内存泄漏，严重时甚至导致程序瘫痪。</p></blockquote><p>&ensp;&ensp;在上一篇博文中，我大概介绍了JVM的内存模型，其中<strong>程序计数器，虚拟机栈，本地方法栈</strong>3个区域随线程而生灭，当方法结束或者线程结束时，内存自然就回收了，所以这3个区域就不需要过多考虑回收的问题。</p><h2 id="如何判断对象已死"><a href="#如何判断对象已死" class="headerlink" title="如何判断对象已死"></a>如何判断对象已死</h2><p>&ensp;&ensp;在堆里面存放着Java世界中几乎所有的对象实例，垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象之中哪些还活着或者死亡。有下面2种方法判断：</p><ul><li>引用计数法<br>&ensp;&ensp;引用计数器的实现很简单，对于一个对象 A，只要有任何一个对象引用了 A，则 A 的引用计数器就加 1，当引用失效时，引用计数器就减 1。只要对象 A 的引用计数器的值为 0，则对象 A 就不可能再被使用。引用计数器的实现也非常简单，只需要为每个对象配置一个整形的计数器即可。<br>&ensp;&ensp;但是引用计数器有一个严重的问题，即无法处理循环引用的情况。因此，在 Java 的垃圾回收器中<strong>没有使用这种算法</strong>。一个简单的循环引用问题描述如下：有对象 A 和对象 B，对象 A 中含有对象 B 的引用，对象 B 中含有对象 A 的引用。此时，对象 A 和对象 B 的引用计数器都不为 0。但是在系统中却不存在任何第 3 个对象引用了 A 或 B。也就是说，A 和 B 是应该被回收的垃圾对象，但由于垃圾对象间相互引用，从而使垃圾回收器无法识别，引起内存泄漏。例如，如下代码就不会GC：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test object1 = <span class="keyword">new</span> Test();</span><br><span class="line">        Test object2 = <span class="keyword">new</span> Test();</span><br><span class="line"></span><br><span class="line">        object1.instance = object2;</span><br><span class="line">        object2.instance = object1;</span><br><span class="line"></span><br><span class="line">        object1 = <span class="keyword">null</span>;</span><br><span class="line">        object2 = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可达性分析（根搜索法）<br>&ensp;&ensp;为了解决上面的循环引用问题，Java采用了一种新的算法：可达性分析算法。<br>从GC Roots（每种具体实现对GC Roots有不同的定义）作为起点，向下搜索它们引用的对象，可以生成一棵引用树，树的节点视为可达对象，反之视为不可达。</li></ul><p><img alt="可达性分析算法" data-src="https://img-blog.csdnimg.cn/20181027164313889.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTczODk5,size_27,color_FFFFFF,t_70" class="lozad"></p><p>在Java语言中，可作为GCRoots的对象包括下面几种：</p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI（即一般说的Native方法）引用的对象</li></ul><h2 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h2><p>&ensp;&ensp;很多人认为方法区（或者HotSpot虚拟机中的永久代）是没有垃圾回收的，Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而且在方法区中进行垃圾收集的性价比一般比较低。<br>&ensp;&ensp;永久代的垃圾收集主要回收两部分内容：<strong>废弃常量和无用的类</strong>。</p><blockquote><p>由于 PermGen 内存经常会溢出，所以在JDK1.8中，PermGen 最终被移除，方法区移至 Metaspace，字符串常量移至 Java Heap。JDK 8 开始把类的元数据放到本地堆内存(native heap)中，这一块区域就叫 Metaspace，中文名叫元空间。默认的类的元数据分配只受本地内存大小的限制</p></blockquote><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记-清除算法-Mark-Sweep"><a href="#标记-清除算法-Mark-Sweep" class="headerlink" title="标记-清除算法 (Mark-Sweep)"></a>标记-清除算法 (Mark-Sweep)</h3><p>&ensp;&ensp;标记-清除算法将垃圾回收分为两个阶段：标记阶段和清除阶段。一种可行的实现是，在标记阶段首先通过根节点，标记所有从根节点开始的较大对象。因此，未被标记的对象就是未被引用的垃圾对象。然后，在清除阶段，清除所有未被标记的对象。该算法最大的问题是存在大量的空间碎片，因为回收后的空间是不连续的。在对象的堆空间分配过程中，尤其是大对象的内存分配，不连续的内存空间的工作效率要低于连续的空间。</p><h3 id="复制算法-Copying"><a href="#复制算法-Copying" class="headerlink" title="复制算法 (Copying)"></a>复制算法 (Copying)</h3><p> &ensp;&ensp;将现有的内存空间分为两快，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收。<br> &ensp;&ensp;如果系统中的垃圾对象很多，复制算法需要复制的存活对象数量并不会太大。因此在真正需要垃圾回收的时刻，复制算法的效率是很高的。又由于对象在垃圾回收过程中统一被复制到新的内存空间中，因此，可确保回收后的内存空间是没有碎片的。该算法的缺点是将系统内存折半。<br> &ensp;&ensp;Java 的新生代串行垃圾回收器中使用了复制算法的思想。例如堆中的新生代分为 eden 空间、from 空间、to 空间 3 个部分。其中 from 空间和 to 空间可以视为用于复制的两块大小相同、地位相等，且可进行角色互换的空间块。from 和 to 空间也称为 survivor 空间，即幸存者空间，用于存放未被回收的对象。<br><img alt="Java堆" data-src="https://img-blog.csdnimg.cn/20181027170934985.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTczODk5,size_27,color_FFFFFF,t_70" class="lozad"><br>&ensp;&ensp;在垃圾回收时，eden 空间中的存活对象会被复制到未使用的 survivor 空间中 (假设是 to)，正在使用的 survivor 空间 (假设是 from) 中的年轻对象也会被复制到 to 空间中 (大对象，或者老年对象会直接进入老年带，如果 to 空间已满，则对象也会直接进入老年代)。此时，eden 空间和 from 空间中的剩余对象就是垃圾对象，可以直接清空，to 空间则存放此次回收后的存活对象。这种改进的复制算法既保证了空间的连续性，又避免了大量的内存空间浪费。</p><h3 id="标记-压缩算法-Mark-Compact"><a href="#标记-压缩算法-Mark-Compact" class="headerlink" title="标记-压缩算法 (Mark-Compact)"></a>标记-压缩算法 (Mark-Compact)</h3><p>&ensp;&ensp;复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在年轻代经常发生，但是在老年代更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活的对象较多，复制的成本也将很高。<br>&ensp;&ensp;标记-压缩算法是一种老年代的回收算法，它在标记-清除算法的基础上做了一些优化。也首先需要从根节点开始对所有可达对象做一次标记，但之后，它并不简单地清理未标记的对象，而是将所有的存活对象压缩到内存的一端。之后，清理边界外所有的空间。这种方法既避免了碎片的产生，又不需要两块相同的内存空间，因此，其性价比比较高。</p><h3 id="分代收集算法-Generational-Collecting"><a href="#分代收集算法-Generational-Collecting" class="headerlink" title="分代收集算法 (Generational Collecting)"></a>分代收集算法 (Generational Collecting)</h3><p>&ensp;&ensp;根据垃圾回收对象的特性，不同阶段最优的方式是使用合适的算法用于本阶段的垃圾回收，分代算法即是基于这种思想，它将内存区间根据对象的特点分成几块，根据每块内存区间的特点，使用不同的回收算法，以提高垃圾回收的效率。以 Hot Spot 虚拟机为例，它将所有的新建对象都放入称为年轻代的内存区域，年轻代的特点是对象会很快回收，因此，在年轻代就选择效率较高的复制算法。当一个对象经过几次回收后依然存活，对象就会被放入称为老生代的内存空间。在老生代中，几乎所有的对象都是经过几次垃圾回收后依然得以幸存的。因此，可以认为这些对象在一段时期内，甚至在应用程序的整个生命周期中，将是常驻内存的。所以根据分代的思想，可以对老年代的回收使用与新生代不同的标记-压缩算法，以提高垃圾回收效率。</p><h2 id="垃圾收集过程"><a href="#垃圾收集过程" class="headerlink" title="垃圾收集过程"></a>垃圾收集过程</h2><ul><li><p>第一，Java应用不断创建对象，通常都是分配在Eden区域，当其空间占用到达一定阈值时，触发Minor GC。仍然被引用的对象（存活的对象，绿色方块），被<strong>复制</strong>到JVM选择的<strong>Survivor 区域其中的from（下图中的S0）</strong>，复制到S0之后，Eden区域可以直接回收，此时Eden的对象就为已经存活的对象（已被复制到S0）和未被引用的对象（即将回收的对象），Eden整个区域就可以直接清除。注意，我给存活对象标记了“数字 1”，这是为了表明对象的存活时间<br><img alt="from区域" data-src="https://img-blog.csdnimg.cn/20181027214024606.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTczODk5,size_27,color_FFFFFF,t_70" class="lozad"></p></li><li><p>第二，经过一次Minor GC，Eden区域就会空闲，直到再次达到Minor GC 触发条件，这时候，另一个<strong>空闲的Survivor 区域</strong>则只有to（下图中的S1）区域，<strong>Eden区域和From区域存活的对象，都会被复制到to区域</strong>，并且存活的年龄计数会被加1。<br><img alt="to区域" data-src="https://img-blog.csdnimg.cn/20181027214316751.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTczODk5,size_27,color_FFFFFF,t_70" class="lozad"></p></li><li><p>第三，类似地尔不得过程会发生很多次，知道有对象年龄计数达到阈值，这时候就会发生所谓的晋升（Promotion），如下图所示，超过阈值的对象会被晋升到老年代。<br><img alt="老年代" data-src="https://img-blog.csdnimg.cn/20181027214530317.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTczODk5,size_27,color_FFFFFF,t_70" class="lozad"></p></li></ul><p>这个阈值是可以通过参数指定：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:MaxTenuringThreshold</span><br></pre></td></tr></table></figure><ul><li>后面就是老年代GC，具体取决于选择的GC选项，对应不同的算法。下面是一个简单标记-压缩算法过程示例图，老年代中的无用对象被清除后，GC会将对象进行整理，以防止内存碎片化。</li></ul><p><img alt="标记压缩" data-src="https://img-blog.csdnimg.cn/2018102721593985.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTczODk5,size_27,color_FFFFFF,t_70" class="lozad"></p><blockquote><p>通常我们把老年代GC 叫做 Major GC，将对整个堆进行清理的GC 叫做 Full GC ，但是这个也没有那么绝对，因为不同的老年代GC算法差异很大，例如，CMS ”concurrent“就体现在清理工作是与工作线程一起并发运行的。</p></blockquote><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p>&ensp;&ensp;上面讲述了4种垃圾收集算法，但这仅仅是理论，那么垃圾收集器就是对这些理论的具体实现。Java虚拟机规范中对垃圾收集器应该如何实现并没有任务规定，因此不同的厂商，不同版本的虚拟机所提供的垃圾收集器都可能会有很大差别，并且一般都会提供参数供用户自己的应用特点和要求组合出各个年代（区域）所使用的收集器。<br>&ensp;&ensp;从不同角度分析垃圾收集器，可以将其分为不同的类型。</p><ul><li><p>按线程数分，可以分为串行垃圾回收器和并行垃圾回收器。串行垃圾回收器一次只使用一个线程进行垃圾回收；并行垃圾回收器一次将开启多个线程同时进行垃圾回收。在并行能力较强的 CPU 上，使用并行垃圾回收器可以缩短 GC 的停顿时间。</p></li><li><p>按照工作模式分，可以分为并发式垃圾回收器和独占式垃圾回收器。并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间；独占式垃圾回收器 (Stop the world) 一旦运行，就停止应用程序中的其他所有线程，直到垃圾回收过程完全结束。</p></li><li><p>按碎片处理方式可分为压缩式垃圾回收器和非压缩式垃圾回收器。压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片；非压缩式的垃圾回收器不进行这步操作。</p></li><li><p>按工作的内存区间，又可分为新生代垃圾回收器和老年代垃圾回收器。<br><img alt="HotSpot虚拟机垃圾收集器" data-src="https://img-blog.csdnimg.cn/20181027194216145.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTczODk5,size_27,color_FFFFFF,t_70" class="lozad"></p></li></ul><h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp; 有两个特点：第一，它仅仅使用单线程进行垃圾回收；第二，它独占式的垃圾回收。使用-XX:+UseSerialGC参数指定使用串行回收器，Jvm运行在Client模式下的默认值，使用Serial + Serial Old的收集器组合进行内存回收。<br><img alt="Serial收集器" data-src="https://img-blog.csdnimg.cn/20181027180905609.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTczODk5,size_27,color_FFFFFF,t_70" class="lozad"><br>Serial进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。</p><h3 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h3><p>&ensp;&ensp;&ensp;&ensp; &ensp;&ensp;它是Serial收集器的老年代版本，和新生代串行收集器一样，它也是一个串行的、独占式的垃圾回收器。它可以作为CMS收集器的后被预案，在并发收集发生 Concurrent Model Failure时使用。<br>&ensp;&ensp;&ensp;&ensp; &ensp;&ensp;使用以下参数：-XX:+UseSerialGC: 新生代、老年代都使用串行回收器。</p><h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p>&ensp;&ensp;&ensp;&ensp; &ensp;&ensp;它仅仅是Serial收集器的多线程版本。并行回收器也是独占式的回收器，在收集过程中，应用程序会全部暂停。但由于并行回收器使用多线程进行垃圾回收，因此，在并发能力比较强的 CPU 上，它产生的停顿时间要短于串行回收器，而在单 CPU 或者并发能力较弱的系统中，并行回收器的效果不会比串行回收器好，由于多线程的压力，它的实际表现很可能比串行回收器差。<br>&ensp;&ensp;&ensp;&ensp; &ensp;&ensp;开启并行回收器可以使用参数-XX:+UseParNewGC，该参数设置新生代使用并行收集器，老年代也使用串行收集器。<br><img alt="ParNew/SerialOld收集器" data-src="https://img-blog.csdnimg.cn/20181027181628220.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTczODk5,size_27,color_FFFFFF,t_70" class="lozad"><br>&ensp;&ensp;设置参数-XX:+UseConcMarkSweepGC 可以要求新生代使用并行收集器，老年代使用 CMS。<br>&ensp;&ensp;并行收集器工作时的线程数量可以使用-XX:ParallelGCThreads 参数指定。一般，最好与 CPU 数量相当，避免过多的线程数影响垃圾收集性能。在默认情况下，当 CPU 数量小于 8 个，ParallelGCThreads 的值等于 CPU 数量，大于 8 个，ParallelGCThreads 的值等于 3+[5*CPU_Count]/8]。以下测试显示了笔者笔记本上运行 8 个线程时耗时最短，本人笔记本是 8 核 IntelCPU。</p><h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><p>&ensp;&ensp;&ensp;&ensp;&ensp;  该收集器是一个新生代收集器，使用复制算法。从表面上看，它和并行收集器一样都是多线程、独占式的收集器。但是，并行回收收集器有一个重要的特点：它非常关注系统的吞吐量。<br>&ensp;&ensp;&ensp;&ensp;&ensp;  -XX:+UseParallelGC:新生代使用<strong>并行</strong>回收收集器，老年代使用串行收集器。</p><blockquote><p>&ensp;&ensp;所谓的吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即 吞吐量 = 运行用户代码时间/（运行用户代码时间+垃圾收集时间），例如，虚拟机总共运行了100分钟，其中垃圾收集花掉了1分钟，那么运行用户代码时间就花费了99分钟，所以，吞吐量就是99％<br>&ensp;&ensp;在其启动时，可以指定如下参数：<br>&ensp;&ensp;&ensp;&ensp;-XX:+MaxGCPauseMills:设置最大垃圾收集停顿时间，它的值是一个大于 0 的整数。收集器在工作时会调整 Java 堆大小或者其他一些参数，尽可能地把停顿时间控制在 MaxGCPauseMills 以内。如果希望减少停顿时间，而把这个值设置得很小，为了达到预期的停顿时间，JVM 可能会使用一个较小的堆 (一个小堆比一个大堆回收快)，而这将导致垃圾回收变得很频繁，从而增加了垃圾回收总时间，降低了吞吐量。<br>&ensp;&ensp;&ensp;&ensp;-XX:+GCTimeRatio：设置吞吐量大小，它的值是一个 0-100 之间的整数。假设 GCTimeRatio 的值为 n，那么系统将花费不超过 1/(1+n) 的时间用于垃圾收集。比如 GCTimeRatio 等于 19，则系统用于垃圾收集的时间不超过 1/(1+19)=5%。默认情况下，它的取值是 99，即不超过 1%的时间用于垃圾收集。<br>&ensp;&ensp;&ensp;&ensp;除此之外，并行回收收集器与并行收集器另一个不同之处在于，它支持一种自适应的 GC 调节策略，使用-XX:+UseAdaptiveSizePolicy 可以打开自适应 GC 策略。在这种模式下，新生代的大小、eden 和 survivor 的比例、晋升老年代的对象年龄等参数会被自动调整，以达到在堆大小、吞吐量和停顿时间之间的平衡点。在手工调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量 (GCTimeRatio) 和停顿时间 (MaxGCPauseMills)，让虚拟机自己完成调优工作。</p></blockquote><h3 id="Parallel-Old"><a href="#Parallel-Old" class="headerlink" title="Parallel Old"></a>Parallel Old</h3><p>&ensp;&ensp;&ensp;&ensp; &ensp;&ensp;它是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。<br>&ensp;&ensp;&ensp;&ensp; &ensp;&ensp;-XX:+UseParallelOldGC:新生代和老年代都是用<strong>并行</strong>回收收集器。<br>&ensp;&ensp;&ensp;&ensp; &ensp;&ensp;参数-XX:ParallelGCThreads 也可以用于设置垃圾回收时的线程数量。</p><h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p>&ensp;&ensp;与并行回收收集器不同，CMS 收集器主要关注于系统停顿时间。CMS 是 Concurrent Mark Sweep 的缩写，意为并发标记清除，从名称上可以得知，它使用的是标记-清除算法，同时它又是一个使用多线程并发回收的垃圾收集器。<br>&ensp;&ensp;CMS 工作时，主要步骤有：初始标记、并发标记、重新标记、并发清除和并发重置。其中初始标记和重新标记是独占系统资源的，而并发标记、并发清除和并发重置是可以和用户线程一起执行的。因此，从整体上来说，CMS 收集不是独占式的，它可以在应用程序运行过程中进行垃圾回收。<br>&ensp;&ensp;根据标记-清除算法，初始标记、并发标记和重新标记都是为了标记出需要回收的对象。并发清理则是在标记完成后，正式回收垃圾对象；并发重置是指在垃圾回收完成后，重新初始化 CMS 数据结构和数据，为下一次垃圾回收做好准备。并发标记、并发清理和并发重置都是可以和应用程序线程一起执行的。<br>&ensp;&ensp;CMS 收集器在其主要的工作阶段虽然没有暴力地彻底暂停应用程序线程，但是由于它和应用程序线程并发执行，相互抢占 CPU，所以在 CMS 执行期内对应用程序吞吐量造成一定影响。CMS 默认启动的线程数是 (ParallelGCThreads+3)/4),ParallelGCThreads 是新生代并行收集器的线程数，也可以通过-XX:ParallelCMSThreads 参数手工设定 CMS 的线程数量。当 CPU 资源比较紧张时，受到 CMS 收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。<br>&ensp;&ensp;由于 CMS 收集器不是独占式的回收器，在 CMS 回收过程中，应用程序仍然在不停地工作。在应用程序工作过程中，又会不断地产生垃圾。这些新生成的垃圾在当前 CMS 回收过程中是无法清除的。同时，因为应用程序没有中断，所以在 CMS 回收过程中，还应该确保应用程序有足够的内存可用。因此，CMS 收集器不会等待堆内存饱和时才进行垃圾回收，而是当前堆内存使用率达到某一阈值时，便开始进行回收，以确保应用程序在 CMS 工作过程中依然有足够的空间支持应用程序运行。<br>&ensp;&ensp;这个回收阈值可以使用-XX:CMSInitiatingOccupancyFraction 来指定，默认是 68。即当老年代的空间使用率达到 68%时，会执行一次 CMS 回收。如果应用程序的内存使用率增长很快，在 CMS 的执行过程中，已经出现了内存不足的情况，此时，CMS 回收将会失败，JVM 将启动老年代串行收集器进行垃圾回收。如果这样，应用程序将完全中断，直到垃圾收集完成，这时，应用程序的停顿时间可能很长。因此，根据应用程序的特点，可以对-XX:CMSInitiatingOccupancyFraction 进行调优。如果内存增长缓慢，则可以设置一个稍大的值，大的阈值可以有效降低 CMS 的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。<br>&ensp;&ensp;标记-清除算法将会造成大量内存碎片，离散的可用空间无法分配较大的对象。在这种情况下，即使堆内存仍然有较大的剩余空间，也可能会被迫进行一次垃圾回收，以换取一块可用的连续内存，这种现象对系统性能是相当不利的，为了解决这个问题，CMS 收集器还提供了几个用于内存压缩整理的算法。<br>&ensp;&ensp;-XX:+UseCMSCompactAtFullCollection 参数可以使 CMS 在垃圾收集完成后，进行一次内存碎片整理。内存碎片的整理并不是并发进行的。-XX:CMSFullGCsBeforeCompaction 参数可以用于设定进行多少次 CMS 回收后，进行一次内存压缩。</p><h3 id="G1-收集器-Garbage-First"><a href="#G1-收集器-Garbage-First" class="headerlink" title="G1 收集器 (Garbage First)"></a>G1 收集器 (Garbage First)</h3><p>&ensp;&ensp;G1 收集器的目标是作为一款服务器的垃圾收集器，因此，它在吞吐量和停顿控制上，预期要优于 CMS 收集器。<br>&ensp;&ensp;与 CMS 收集器相比，G1 收集器是基于标记-压缩算法的。因此，它不会产生空间碎片，也没有必要在收集完成后，进行一次独占式的碎片整理工作。G1 收集器还可以进行非常精确的停顿控制。它可以让开发人员指定当停顿时长为 M 时，垃圾回收时间不超过 N。使用参数-XX:+UnlockExperimentalVMOptions –XX:+UseG1GC 来启用 G1 回收器，设置 G1 回收器的目标停顿时间：-XX:MaxGCPauseMills=20,-XX:GCPauseIntervalMills=200。</p><p><strong>比较不幸的是CMS GC</strong>，因为其算法的理论缺陷等原因，虽然现在还有非常大的用户群体，到那时已经被标记为废弃，如果没有组织主动承担CMS的维护，很有可能在未来版本移除。如果你有关注目前尚处于开发中的JDK11，你会发现，JDK又增加了两种全新的GC方式，分别是：</p><ul><li>Epsilon GC：简单说就是个不做垃圾收集的GC，似乎有点奇怪，有的情况下，例如在进行性能测试的时候，可能需要明确判断GC本身产生了多大的开销，这就是其典型的应用场景</li><li>ZGC：这是Oracle 开源出来的一个超级GC实现，具备令人惊讶的扩展能力，比如支持T byte级别的堆大小，并且保证绝大部分情况下，延迟都不会超过10 ms。虽然目前还处于实验阶段，仅支持Linux64位的平台，但其已经表现出的能力和潜力都非常令人期待。</li></ul><blockquote><p>垃圾回收的使用没有那么绝对，调优永远是针对 特定场景、特定需求、不存在一劳永逸的指标，一般建议堆30G以上慎用CMS，Cassandra的官方指南建议用在16G以内。</p></blockquote><h2 id="GC-相关参数总结"><a href="#GC-相关参数总结" class="headerlink" title="GC 相关参数总结"></a>GC 相关参数总结</h2><h4 id="与串行回收器相关的参数"><a href="#与串行回收器相关的参数" class="headerlink" title="与串行回收器相关的参数"></a>与串行回收器相关的参数</h4><ul><li>-XX:+UseSerialGC:在新生代和老年代使用串行回收器。</li><li>-XX:+SurvivorRatio:设置 eden 区大小和 survivor 区大小的比例。</li><li>-XX:+PretenureSizeThreshold:设置大对象直接进入老年代的阈值。当对象的大小超过这个值时，将直接在老年代分配。</li><li>-XX:MaxTenuringThreshold:设置对象进入老年代的年龄的最大值。每一次 Minor GC 后，对象年龄就加 1。任何大于这个年龄的对象，一定会进入老年代。</li></ul><h4 id="ensp-ensp-与并行-GC-相关的参数"><a href="#ensp-ensp-与并行-GC-相关的参数" class="headerlink" title="&ensp;&ensp;与并行 GC 相关的参数"></a>&ensp;&ensp;与并行 GC 相关的参数</h4><ul><li>-XX:+UseParNewGC: 在新生代使用并行收集器。</li><li>-XX:+UseParallelOldGC: 老年代使用并行回收收集器。</li><li>-XX:ParallelGCThreads：设置用于垃圾回收的线程数。通常情况下可以和 CPU 数量相等。但在 CPU 数量比较多的情况下，设置相对较小的数值也是合理的。</li><li>-XX:MaxGCPauseMills：设置最大垃圾收集停顿时间。它的值是一个大于 0 的整数。收集器在工作时，会调整 Java 堆大小或者其他一些参数，尽可能地把停顿时间控制在 MaxGCPauseMills 以内。</li><li>-XX:GCTimeRatio:设置吞吐量大小，它的值是一个 0-100 之间的整数。假设 GCTimeRatio 的值为 n，那么系统将花费不超过 1/(1+n) 的时间用于垃圾收集。</li><li>-XX:+UseAdaptiveSizePolicy:打开自适应 GC 策略。在这种模式下，新生代的大小，eden 和 survivor 的比例、晋升老年代的对象年龄等参数会被自动调整，以达到在堆大小、吞吐量和停顿时间之间的平衡点。</li></ul><h4 id="与-CMS-回收器相关的参数"><a href="#与-CMS-回收器相关的参数" class="headerlink" title="与 CMS 回收器相关的参数"></a>与 CMS 回收器相关的参数</h4><ul><li>-XX:+UseConcMarkSweepGC: 新生代使用并行收集器，老年代使用 CMS+串行收集器。</li><li>-XX:+ParallelCMSThreads: 设定 CMS 的线程数量。</li><li>-XX:+CMSInitiatingOccupancyFraction:设置 CMS 收集器在老年代空间被使用多少后触发，默认为 68%。</li><li>-XX:+UseFullGCsBeforeCompaction:设定进行多少次 CMS 垃圾回收后，进行一次内存压缩。</li><li>-XX:+CMSClassUnloadingEnabled:允许对类元数据进行回收。</li><li>-XX:+CMSParallelRemarkEndable:启用并行重标记。</li><li>-XX:CMSInitatingPermOccupancyFraction:当永久区占用率达到这一百分比后，启动 CMS 回收 (前提是-XX:+CMSClassUnloadingEnabled 激活了)。</li><li>-XX:UseCMSInitatingOccupancyOnly:表示只在到达阈值的时候，才进行 CMS 回收。</li><li>-XX:+CMSIncrementalMode:使用增量模式，比较适合单 CPU。</li></ul><h4 id="与-G1-回收器相关的参数"><a href="#与-G1-回收器相关的参数" class="headerlink" title="与 G1 回收器相关的参数"></a>与 G1 回收器相关的参数</h4><ul><li>-XX:+UseG1GC：使用 G1 回收器。</li><li>-XX:+UnlockExperimentalVMOptions:允许使用实验性参数。</li><li>-XX:+MaxGCPauseMills:设置最大垃圾收集停顿时间。</li><li>-XX:+GCPauseIntervalMills:设置停顿间隔时间。</li></ul><h4 id="其他参数"><a href="#其他参数" class="headerlink" title="其他参数"></a>其他参数</h4><ul><li>-XX:+DisableExplicitGC: 禁用显示 GC。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
            <tag> 垃圾回收 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM之内存模型</title>
      <link href="/2018/10/25/JVM%E4%B9%8B%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
      <url>/2018/10/25/JVM%E4%B9%8B%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM之内存模型"><a href="#JVM之内存模型" class="headerlink" title="JVM之内存模型"></a>JVM之内存模型</h1><blockquote><p>Java虚拟机把管理的内存划分为若干不同的数据区域， 由类加载器(classloader) +，执行引擎(execution engine) +，运行时数据区域(runtime data area) 组成。<br><img alt="Java运行时数据区" data-src="https://img-blog.csdnimg.cn/20181025210712619.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTczODk5,size_27,color_FFFFFF,t_70" class="lozad"></p></blockquote><h2 id="程序计算器-PC，Program-Counter-Register"><a href="#程序计算器-PC，Program-Counter-Register" class="headerlink" title="程序计算器(PC，Program Counter Register)"></a>程序计算器(PC，Program Counter Register)</h2><p>&ensp;&ensp;是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在JVM规范中，每个线程都有它自己的程序计数器，并且任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是在执行本地方法，则是未指定值（undefined）。字节码解释器通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支，循环，跳转，异常处理，线程恢复等基础功能都需要依赖这个计数器来完成。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域</p><h2 id="Java虚拟机栈-Java-Virtual-Machine-Stack"><a href="#Java虚拟机栈-Java-Virtual-Machine-Stack" class="headerlink" title="Java虚拟机栈(Java Virtual Machine Stack)"></a>Java虚拟机栈(Java Virtual Machine Stack)</h2><p>&ensp;&ensp;早期也叫Java栈。每个线程在创建时，都会创建一个虚拟机栈，其内部保存一个个的栈帧（StackFrame），用于存储<strong>局部变量表</strong>、操作数栈、帧数据区、动态链接、方法出口等信息。<strong>在一个时间点，对应的只会有一个活动的栈帧，通常叫做当前帧</strong>，方法所在的类叫做当前类。如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，成为新的当前帧，一直到它返回结果或者执行结束。JVM直接对Java栈的操作只有两个，就是对栈帧的压栈和出栈。</p><p>&ensp;&ensp; 局部变量表存放了编译期可知的各种基本数据类型（Boolean，byte，char，short，int，float，long。double）、对象引用和returnAddress（指向了一条字节码指令的地址）。</p><p>&ensp;&ensp; 操作数栈主要保存计算过程的中间结果，同时作为计算过程中变量的临时存储空间。</p><p>&ensp;&ensp;  除了局部变量表和操作数栈外，栈还需要一些数据来支持常量池的解析，这里帧数据区保存着访问常量池的指针，方便程序访问常量池，另外，当方法返回或者出现异常时，虚拟机必须有一个异常处理表，方便发送异常的时候找到异常的代码，因此异常处理表也是帧数据区的一部分。</p><p>在Java虚拟机规范中，对这个区域规定了两种异常情况：</p><ul><li>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverFlowError异常。比如。不合适的递归方法可能导致此问题。</li><li>如果虚拟机栈可以动态扩展（当前大部分虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），如果扩展时无法申请到足够的内存， 就会抛出OutOfMemoryError。</li></ul><h2 id="本地方法栈（Native-Method-Stack）"><a href="#本地方法栈（Native-Method-Stack）" class="headerlink" title="本地方法栈（Native Method Stack）"></a>本地方法栈（Native Method Stack）</h2><p>&ensp;&ensp;它和Java虚拟机栈是非常相似的，也是线程私有的，虚拟机栈执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。在Oracle HotSpot JVM中，本地方法栈和Java虚拟机栈是在同一块区域，这完全取决与技术实现的决定，并未在规范中强制。也会抛出StackOverFlowError和OutOfMemoryError异常。</p><h2 id="Java堆（Heap）"><a href="#Java堆（Heap）" class="headerlink" title="Java堆（Heap）"></a>Java堆（Heap）</h2><p>&ensp;&ensp;它是Java内存管理的核心区域，用来放置Java对象的实例，几乎所有创建的Java对象实例都是被直接分配在堆上。堆被所有的线程共享，在虚拟机启动时，我们指定“Xmx”之类的参数就是用来指定最大堆空间等指标。Java堆是垃圾收集器管理的主要区域，由于现在收集器基本都采用<strong>分代收集算法</strong>，所以Java堆中还可以细分为：新生代（又分，Eden、From survivor，To survivor），老年代。从内存分配的角度来看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）。</p><p>&ensp;&ensp;根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上连续即可。如果堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError。<br><img alt="Java堆" data-src="https://img-blog.csdnimg.cn/20181025224712982.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTczODk5,size_27,color_FFFFFF,t_70" class="lozad"></p><h2 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h2><p>&ensp;&ensp;这也是所有线程共享的一块内存区域，用于存储所谓的元数据（Meta Data），例如类结构信息，以及对应的运行时常量池，字段，方法代码等。由于早期的HotSpotJVM实现，很多人习惯于将方法区称为永久代（Permanent Generation）。Oracle JDK8中将永久代移除，同时增加了<strong>元数据区（MetaSpace）</strong>，存储在<strong>本地堆内存</strong>。</p><p>&ensp;&ensp;Java虚拟机规范对方法区的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者扩展外，还可以选择<strong>不实现垃圾收集</strong>。垃圾收集行为在这个区域是比较少出现的，并且回收能力总是不尽人意。根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError，常见的场景就是，项目引入的jar包过多，类过多。</p><h2 id="运行时常量池（Runtime-Constant-Pool）"><a href="#运行时常量池（Runtime-Constant-Pool）" class="headerlink" title="运行时常量池（Runtime Constant Pool）"></a>运行时常量池（Runtime Constant Pool）</h2><p>&ensp;&ensp;这是方法区的一部分。如果仔细分析过反编译的类文件结构，你能看到版本号、字段、方法、超类、接口等各种信息，还有一项信息就是常量池。Java的常量池可以存放各种常量信息，不管是编译器生成的各种字面量，还是需要在运行时决定的符号引用，所以，它比一般语言的符号表存储的信息更加宽泛。<br>运行时常量池是方法区的一部分，当无法再申请到内存时，也会抛出OutOfMemoryError。</p><h2 id="直接内存（Direct-Memory）"><a href="#直接内存（Direct-Memory）" class="headerlink" title="直接内存（Direct Memory）"></a>直接内存（Direct Memory）</h2><p>&ensp;&ensp;直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError 异常出现。在 JDK 1.4 中新加入了 NIO 类，引入了一种基于通道（Channel）与缓冲区（Buffer）的 I/O方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java 堆和 Native 堆中来回复制数据。</p><h2 id="对象是在堆上分配的还是栈上？"><a href="#对象是在堆上分配的还是栈上？" class="headerlink" title="对象是在堆上分配的还是栈上？"></a>对象是在堆上分配的还是栈上？</h2><p>&ensp;&ensp;随着<strong>JIT</strong>编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了，在编译期间，JIT会对代码做很多优化。其中有一部分优化的目的就是减少内存堆分配压力，其中一种重要的技术叫做<strong>逃逸分析</strong><br>逃逸分析(Escape Analysis)是目前Java虚拟机中比较前沿的优化技术。这是一种可以有效减少Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中，称为方法逃逸。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringBuffer <span class="title">craeteStringBuffer</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">   StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">   sb.append(s1);</span><br><span class="line">   sb.append(s2);</span><br><span class="line">   <span class="keyword">return</span> sb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上述代码中，StringBuffer sb是一个方法内部变量，上述代码中直接将sb返回，这样这个StringBuffer有可能被其他方法所改变，这样它的作用域就不只是在方法内部，虽然它是一个局部变量，称其逃逸到了方法外部。甚至还有可能被外部线程访问到，譬如赋值给类变量或可以在其他线程中访问的实例变量，称为线程逃逸。</p></blockquote><p>如果想要StringBuffer sb不逃出方法，可以这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">createStringBuffer</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">   StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">   sb.append(s1);</span><br><span class="line">   sb.append(s2);</span><br><span class="line">   <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不直接返回 StringBuffer，那么StringBuffer将不会逃逸出方法。换句话说，可以使用逃逸分析将堆分配转化为栈分配。</p><h2 id="JVM常用参数配置"><a href="#JVM常用参数配置" class="headerlink" title="JVM常用参数配置"></a>JVM常用参数配置</h2><table><thead><tr><th>参数名称</th><th>含义</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>-Xms</td><td>初始堆大小</td><td>物理内存的1/64(&lt;1GB)</td><td>默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制.</td></tr><tr><td>-Xmx</td><td>最大堆大小</td><td>物理内存的1/4(&lt;1GB)</td><td>默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制</td></tr><tr><td>-XX:NewSize</td><td>设置年轻代大小(for 1.3/1.4)</td><td></td><td>增大年轻代后,将会减小年老代大小.此值对系统性能影响较大,Sun官方推荐配置为整个堆的3/8</td></tr><tr><td>-XX:MaxNewSize</td><td>年轻代最大值(for 1.3/1.4)</td><td></td><td></td></tr><tr><td>-XX:PermSize</td><td>设置持久代(perm gen)初始值</td><td>物理内存的1/64</td><td>1.8及其以后废除</td></tr><tr><td>-XX:MaxPermSize</td><td>设置持久代最大值</td><td>物理内存的1/4</td><td>1.8及其以后废除</td></tr><tr><td>-XX:MetaspaceSize</td><td>设置持久代最大值</td><td>物理内存的1/4</td><td>1.8</td></tr><tr><td>-XX:MaxPermSize</td><td>分配给类元数据空间的初始大小</td><td></td><td>JDK1.8后，及其以后废除此值为估计值。MetaspaceSize的值设置的过大会延长垃圾回收时间。垃圾回收过后，引起下一次垃圾回收的类元数据空间的大小可能会变大。</td></tr><tr><td>-XX:MaxMetaspaceSize</td><td>分配给类元数据空间的最大值</td><td></td><td>超过此值就会触发Full GC，此值默认没有限制，但应取决于系统内存的大小。JVM会动态地改变此值。</td></tr><tr><td>-Xss</td><td>每个线程的堆栈大小</td><td></td><td>JDK5.0以后每个线程堆栈大小为1M,以前每个线程堆栈大小为256K.更具应用的线程所需内存大小进行 调整.在相同物理内存下,减小这个值能生成更多的线程.但是操作系统对一个进程内的线程数还是有限制的,不能无限生成,经验值在3000~5000左右一般小的应用， 如果栈不是很深， 应该是128k够用的 大的应用建议使用256k。</td></tr><tr><td>-XX:ThreadStackSize</td><td>Thread Stack Size</td><td></td><td>线程堆栈大小</td></tr><tr><td>-XX:NewRatio</td><td>年轻代(包括Eden和两个Survivor区)与年老代的比值(除去持久代)</td><td></td><td>-XX:NewRatio=4表示年轻代与年老代所占比值为1:4,年轻代占整个堆栈的1/5Xms=Xmx并且设置了Xmn的情况下，该参数不需要进行设置。</td></tr><tr><td>-XX:SurvivorRatio</td><td>Eden区与Survivor区的大小比值</td><td></td><td>设置为8,则两个Survivor区与一个Eden区的比值为2:8,一个Survivor区占整个年轻代的1/10</td></tr><tr><td>-XX:LargePageSizeInBytes</td><td>设置堆的内存页大小。</td><td>默认4m，amd64位：2m</td><td>内存页的大小不可设置过大， 会影响Perm的大小</td></tr><tr><td>-XX:+UseFastAccessorMethods</td><td>原始类型的快速优化</td><td>默认启用。</td><td>启用原始类型的getter方法优化。</td></tr><tr><td>-XX:-DisableExplicitGC</td><td>关闭System.gc()</td><td>默认不启用</td><td>禁止在运行期显式地调用 System.gc()。开启该选项后，GC的触发时机将由GarbageCollector全权掌控。</td></tr><tr><td>-XX:MaxTenuringThreshold</td><td>垃圾最大年龄</td><td></td><td>如果设置为0的话,则年轻代对象不经过Survivor区,直接进入年老代. 对于年老代比较多的应用,可以提高效率.如果将此值设置为一个较大值,则年轻代对象会在Survivor区进行多次复制,这样可以增加对象再年轻代的存活 时间,增加在年轻代即被回收的概率该参数只有在串行GC时才有效。</td></tr><tr><td>-XX:+AggressiveOpts</td><td>加快编译。</td><td>JDK6默认启用。</td><td>启用JVM开发团队最新的调优成果。例如编译优化，偏向锁，并行年老代收集等。</td></tr><tr><td>-XX:+UseBiasedLocking</td><td>启用偏向锁。</td><td>JDK6默认启用。</td><td>锁机制的性能改善</td></tr><tr><td>-Xnoclassgc</td><td>禁用垃圾回收。</td><td></td><td></td></tr><tr><td>-XX:SoftRefLRUPolicyMSPerMB</td><td>每兆堆空闲空间中SoftReference的存活时间。</td><td>1s</td><td>softly reachable objects will remain alive for some amount of time after the last time they were referenced. The default value is one second of lifetime per free megabyte in the heap</td></tr><tr><td>-XX:PretenureSizeThreshold</td><td>对象超过多大是直接在旧生代分配。</td><td>0</td><td>单位字节 新生代采用Parallel Scavenge GC时无效另一种直接在旧生代分配的情况是大的数组对象,且数组中无外部引用对象。</td></tr><tr><td>-XX:TLABWasteTargetPercent</td><td>TLAB占eden区的百分比。</td><td>1%</td><td></td></tr><tr><td>-XX:+CollectGen0First</td><td>FullGC时是否先YGC。</td><td>false</td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
            <tag> 内存模型 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
